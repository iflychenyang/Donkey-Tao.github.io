<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[iOS8环境下UITextView出现的内存泄露]]></title>
      <url>%2F2017%2F03%2F22%2FiOS8%E4%B8%ADUITextView%E7%9A%84%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[[UITextView textInputView:] message sent to deallocated instance 今天测试说项目在iOS8环境下其中的用户反馈点击进入并返回后再次进入后点击UITextView时软件会直接闪退，并且能够百分之百重现。这个问题在iOS7、iOS9、iOS10上均没有出现。 连接在电脑上调试时没有打印出相关的错误信息，然后打开Enable Zombie Objects后控制台打印出了错误信息如下： 1[UITextView textInputView:] message sent to deallocated instance 说明是产生了内存泄漏了。但是，这个问题只是出现在iOS8系统的手机上，并且能够百分之百重现，这就有点奇怪了。在网上搜到了相似的问题： http://stackoverflow.com/questions/35715601/uitextfield-textinputview-message-sent-to-deallocated-instance http://stackoverflow.com/questions/40459924/uitextfield-textinputview-message-sent-to-deallocated-instance-ios-8 发现可能是引入第三方的分类引起的。一开始以为Category中可能是某个监听没有移除掉导致的。但实际检查分类后发现通知都已经移除了，而且其他版本没有问题，最后将引入的 Category 中 dealloc 方法注释掉，就不会闪退了。 此处是内存问题，分析问题时不能只看系统 的UITextView这个类，还要分析他的分类。此处，从监听等多方面考虑。但是，iOS8提前释放了UITextView类型的对象，iOS8 和 iOS 9的内存处理可能确实有点不同，在此没有具体弄清楚是什么机理。如有知道具体原因的望不吝告知~谢谢！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[将自己的开源框架发布到CocoaPods]]></title>
      <url>%2F2017%2F03%2F16%2F2017-03-16-%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6%E5%8F%91%E5%B8%83%E5%88%B0CocoaPods%2F</url>
      <content type="text"><![CDATA[​ 我们在iOS开发过程中经常会使用一些第三方框架。例如，比较著名的AFNetworking等。在使用这些框架时，我们只要在项目的根目录下新建podfile文件，并且在podfile文件中添加相关的框架名称（以及版本号），然后使用pod install命令即可很方便的将其加到我们自己的项目中。 ​ 如果我们也想将自己写的框架或者组件开源出去并且让别人也可以通过pod install命令安装自己的框架，那么怎样才能办到呢？ ​ 下面我们来一步一步实现将自己的框架或者组件发布到Cocoapods上。 简单的准备GitHub上面的项目打tag​ 我们一般会将自己的开源项目放在GitHub上面，但是很多时候没有对项目的版本进行一些标记。我们在pod别人的项目时，经常会在后面加上版本号。我们也需要对自己的开源框架进行版本标记，以便来区分各个版本。要想让我们自己的开源框架各个版本有自己的标记，为此我们要在一个版本完成后，对这个版本进行标记。具体操作如下： 首先我们需要在本地打tag: 12git tag -a 0.0.1 -m "0.0.1"git push origin master 然后提交tag到GitHub上 1git push origin --tag 创建并配置Podspec文件Podspec文件的简单介绍创建Podspec文件​ 下面我来通过我自己的一个开源项目:TFNetworking来讲解这个过程。 ​ 我们之前发布在GitHub上的项目在打上tag后，现在我们需要进入项目根目录,在项目的根目录中初始化一个Podspec文件； 1pod spec create TFNetworking ​ 执行完该命令后会在本目录下会生成一个名为TFNetworking.podspec的文件。用编辑器打开这个文件，里面会有丰富的说明配置信息。 配置Podspec文件​ Podspec文件中可以配置的东西有很多，在此我只简单介绍下常用的一些配置。声明我们开源的框架的代码目录和资源目录以及第三方库所依赖的iOS核心框架和第三方库。 1234567891011121314151617181920Pod::Spec.new do |s| s.name = "TFNetworking" s.version = "0.0.1" s.summary = "A framework for iOS networking" s.description = &lt;&lt;-DESC Dabay tech : A framework for iOS networking DESC s.homepage = "https://github.com/Donkey-Tao/TFNetworking" s.license = "MIT" s.author = &#123; "Tao Fei" =&gt; "taofei0610@gmail.com" &#125; s.social_media_url = "http://taofei.me" s.platform = :ios, "8.0" s.source = &#123; :git =&gt; "https://github.com/Donkey-Tao/TFNetworking.git", :tag =&gt; "#&#123;s.version&#125;" &#125; s.source_files = "TFNetworking", "TFNetworking/**/*.&#123;h,m&#125;" s.framework = "CFNetwork" s.requires_arc = true s.dependency "AFNnetworking", "~&gt; 3.1.0"end s.name是我们库的名称，s.version是库原代码版本号，s.summary是对我们库的一个简单的介绍，s.homepage声明库的主页，s.license是所采用的授权版本，s.author是库的作者。s.platform是我们库所支持的软件平台，这在我们最后提交进行编译时有用。s.source声明原代码的地址。我这里是托管在GitHub上,所以这里将地址copy过来就行了。 对于很多第三方库而言，在发布的时候都会打上一个tag，如版本0.0.1就会打上一个名为0.0.1的tag,你也可以选择一个最新的commit来作为该库0.0.1版的代码, 那么最终source就是这样了： 1&#123;:git =&gt; "https://github.com/Donkey-Tao/TFNetworking.git", :commit =&gt; '65584b0e0b08e01f83e66d487180c164b5182409'&#125; 我这里还是使用的tag，所以我这里就是这样的： 1&#123; :git =&gt; "https://github.com/Donkey-Tao/TFNetworking.git", :tag =&gt; "0.0.1" &#125; 以后我们的库有新版本时，我们可以修改相应的version和source。 s.source_files声明了我们库的源代码的位置，所以这个地方不能填错了。 到此我们看下我的目录结构： 所以工程根目录下的TFNetworking文件夹才是库的原代码目录。 1s.source_files = "TFNetworking", "TFNetworking/**/*.&#123;h,m&#125;" 目录的层级关系一定要跟代码库的保持一致。这里前一部分可以不用的，因为我这里后一部分的TFNetworking/*与前面是一致的，这个指定的目录下的文件都会进行编译。如果该目录下还有一些资源文件（如图片等），这些文件并不需要进行编译。可以使用s.resourcs声明。.{h,m}是一个类似正则表达式的字符串，表示匹配所有以.h和.m为扩展名的文件。 s.framework声明了所依赖的核心库，我这里只用到了UIKit,所以是这样的： 1s.framework = "UIKit" 如果你的项目中依赖多个库，可以使用 1s.frameworks = "SomeFramework", "AnotherFramework" 当然，我们开发的库中也可能还依赖第三方库，例如JSONKit，那么，就可以做如下声明: 1s.dependency "AFNetworking", "~&gt; 3.1.0" 如果有多个需要填写多个s.dependency。 遇到的错误： 123[!] The spec did not pass validation, due to 2 errors and 1 warning.[!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run: `echo "2.3" &gt; .swift-version`. 执行上面提示的命令即可； 1echo "2.3" &gt; .swift-version 1- ERROR | [iOS] xcodebuild: Returned an unsuccessful exit code. You can use `--verbose` for more information. 1- ERROR | xcodebuild: TFNetworking/TFNetworking/JHNetWorkTools.h:10:9: error: 'AFNetworking.h' file not found with &lt;angled&gt; include; use "quotes" instead 1- WARN | xcodebuild: TFNetworking/TFNetworking/TFNetWorkingManeger.m:238:22: warning: unused variable 'status' [-Wunused-variable] 在进行 编辑完podspec文件后，需要验证一下这个文件是否可用，如果有任何WARNING或者ERROR都是不可以的，它就不能被添加到Spec Repo中，不过xcode的WARNING是可以存在的，验证需要执行命令： 1pod spec lint TFNetworking.podspec 当看到TFNetworking passed validation.时，说明验证通过了。 编辑好podspec文件后就可以将该podspec文件保存到本机的~/.cocoapods/repos/master/Specs目录中仅供自己使用，也可以将其提交到CocoaPods/Specs代码库中。下面我们先将其保存到本机中： 下面可以看一下是否可以通过搜索找到该库: 同样在需要依赖于HUPhotoBrowser这个库的项目，可以将下列添加到项目的Podfile文件中 1pod 'TFNetworking', '~0.0.1' 保存文件，并用pod install安装HUPhotoBrowser库。 通过以上步骤创建Pod库还只能供自己使用，下面会继续讲解如何将其提交到CocoaPods/Specs代码库中，让其他人也可以通过pod install安装我们的开源库。 CocoaPods Trunk发布自己的Pods 在cocoapods使用了trunk之后，CocoaPods 需要0.33以上版本，用 pod –version查看版本，如果版本低，需要更新。 注册Trunk 1$ pod trunk register orta@cocoapods.org 'Orta Therox' --description='macbook air' 大家在注册时需要替换成自己的邮箱和用户名，一切顺利的话就会受到一份邮件，点击邮件中的链接后验证一下： 1pod trunk me 当然，如果你的pod是由多人维护的，你也可以添加其他维护者: 1$ pod trunk add-owner ARAnalytics kyle@cocoapods.org 上面的工作完成之后，我们就可以开始 trunk push了。 Trunk push pod trunk push 命令会首先验证你本地的podspec文件(是否有错误)，之后会上传spec文件到trunk，最后会将你上传的podspec文件转换为需要的json文件。在工程根目录(包含有.podspec)下执行命令： 1pod trunk push 如果在trunk push过程中报错了，仔细查看一下错误信息。我当初就是使用了podspec文件中描述的版本所没有的API，之后修改podspec文件中s.platform = :ios, “7.0”就可以了。 如果你能看的上面的结果说明上传成功了。我们也可以在本地的~/.cocoapods/repos/master/Specs目录下看到转换之后的json文件, 至此我们整个制作自己的开源库的过程就完成了，以后有新版本只需要修改工程根目录下的podspec文件就行了，然后重新执行pod trunk push命令。 最后 最后对这个过程做个总结： 1.开源库发布之后，需要打上tag 2.进入到项目根目录下，创建podspec文件 1pod spec create PodName 3.编辑podspec文件中的相关信息，有两个比较重要的地方s.source和s.source_files,可以验证是否有误： 1pod spec lint TFNetworking.podspec 4.注册pod trunk 1$ pod trunk register taofei0610@gmail.com 'Tao Fei' --description='MacBook Pro Donkey-Tao' 5.发布到pod trunk 1pod trunk push [NAME.podspec] 该命令在包含有.podspec文件的目录下执行 6.更新pod库 1pod setup 如果pod trunk push成功后无法pod search到自己的库，可执行该命令。 最后的最后 哈哈。好吧，我承认其实我是来打广告的。例子中的TFNetworking是我开源的一个图片浏览器的库，使用起来非常简单，一行代码就以实现图片浏览功能，支持本地和网络图片。希望大家可以支持一下，欢迎大家star。如果有什么问题的话可以直接issue我。最后，希望能跟大家共同进步。项目地址：TFNetworking 参考文章http://www.cocoachina.com/ios/20160301/15459.html https://github.com/trending http://www.cnblogs.com/Keys/p/5245143.html http://www.cnblogs.com/marlonxlj/p/6062646.html http://blog.csdn.net/th_gsb/article/details/50114331 http://blog.csdn.net/tsite/article/details/59547646 http://zeeyang.com/archives/ http://blog.csdn.net/hellozsmj/article/details/50725370 http://www.jianshu.com/p/8a7b9232cbab http://www.cnblogs.com/zhanglinfeng/p/6283178.html pod新版本时出现的问题 1[!] There was an error pushing a new version to trunk: getaddrinfo: nodename nor servname provided, or not known 解决办法：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Xcode8.2.1自动配置证书进行打包遇到的问题]]></title>
      <url>%2F2017%2F03%2F09%2F2017-03-09-Xcode8.2.1%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%AF%81%E4%B9%A6%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8C%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[声明：本文为博主原创，如需转载请注明出处。 问题描述： 1Failed to locate or generate matching signing assets，You account already has a valid iOS Distribution certificate 这个问题是勾选Automatically manager signing生成IPA文件时产生的，之前一直是自己手动配置Profiles、app IDs和Certificates，没有勾选过Automatically manager signing生成IPA文件，在出现上述问题的弹框时没有仔细查看原因直接try again后没能解决就reset了一下，然后再try again时就能够继续打包了。但是，这样做虽然这次可以生成IPA包，看上去没有任何问题。其实，这样做的后果很严重，点击reset后Xcode会自动发送网络请求到开发者中心去生成新的Distribution Certificate，如果之前开发者账号已经有两个发布证书，由于一个开发者账号只能生成两个Distribution Certificate，所以系统会默认revoke掉之前已经有已有的一个发布证书。这样如果revoke的证书是别人创建的，会影响到这个生产证书的相关的电脑证书环境异常(因为以前配置在这台电脑的生产证书已经在苹果的开发者中心找不到了)，还会影响到用被revoke的证书之前生成的描述文件失效。 问题排查：之前用Xcode打包时没注意到这个问题，但是由于Xcode revoke 了之前别的同事创建的Distribution Certificate，所以别的同事在打包时Xcode会自动创建新的Distribution Certificate并revoke了之前其他的Distribution Certificate，这样导致每次打包都会创建新的发布证书，导致之前生成的描述文件全部失效。发现这个问题是因为打好的包放到蒲公英上经常不能下载，进入开发者中心后发现，发现Distribution Certificate都是最近生成的(另外，web页面的开发中心中生成的发布证书的显示时间跟我天朝的北京时间的市区是不一样的，之前看到证书的生成时间也让我很不解)。这样以前的描述文件跟现在的发布证书不一致，这才确定所有描述文件失效的原因。 问题成因：因为Xcode在自动进行Profiles、app IDs和Certificates的配置时没有找到相应的发布证书，可能成因是之前没有安装相应的生产证书。我这之所以出现这样的问题，是因为之前同事只发给我两个推送相关的证书的p12文件，没有生产证书的p12文件，在安装后没有进行检查缺少了生产证书的p12文件。 解决办法：需要去开发者中心进行下载后安装，如果要用的生产证书是别人生产的，那么需要从生产该证书的那台电脑上去导出p12文件，然后安装到自己进行打包的电脑上。 谨记：在勾选Automatically manager signing生成IPA文件时产生的时，出现异常问题要谨慎查看原因，遇到reset相关提示时要特别注意，防止Xcode自动在开发者中心中修改了或者revoke了之前别人创建好的证书之类。以后开发或者打包时一定要仔细检查使用的电脑上是否已经装有开发证书和生产证书，以免出现Xcode自动生成证书并revoke了之前的证书。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift练手项目:新浪微博]]></title>
      <url>%2F2016%2F04%2F01%2F2016-04-01-Swift%E9%A1%B9%E7%9B%AE%2F</url>
      <content type="text"><![CDATA[声明：本文为博主原创，如需转载请注明出处。 本项目使用swift3完成。 写在项目之前： Swift中自定义LOG:在Debug环境下打印内容，但是在Release环境下不显示打印 自定义标记-&gt;项目 -&gt;buildSettings -&gt; Swift flag -&gt; Debug -&gt;-D DEBUG if DEBUG 和endif 1.获取所在文件： 12// 1.获取打印所在的文件let file=(#file as NSString).lastPathComponent 2.获取打印所在的方法 12// 2.获取打印所在的方法let funcName = #function 3.获取打印所在的行 12// 3.获取打印所在行数let lineNum = #line 4.整个到一个TFLog函数中，并将函数放在AppDelegae.swift中，这样可以实现整个项目中都可以用，利于团队合作。 1234567func TFLog&lt;T&gt;(_ messsage : T, file : String = #file, funcName : String = #function, lineNum : Int = #line) &#123; #if DEBUG let fileName = (file as NSString).lastPathComponent print("\(fileName):(\(lineNum))-\(messsage)") #endif&#125; 其中上面函数中的 123#if DEBUG#endif ​ 可以通过TAGETS -&gt; Build Settings -&gt; Other Swift Flags -&gt; Debug -&gt;Any Architecture|Any SDK方式修改，在其中添加”-D DEBUG”，表示debug环境下有这样的一个标记。加上上面的这些就可以让TFLog()打印的东西在Debug环境下显示，在Release环境下不显示。 ​ 到此在项目中以后就可以使用这样的自定义的TFLog()函数作为打印调试用，以后在其他的项目中也可以直接拿过去就用。 项目的部署:OSChina基本步骤： 在OSChina上创建远程代码仓库 将仓库clone到本地 添加.gitignore文件-&gt;pods 初始化项目 将项目提交到远程代码仓库 本项目采用Git管理源代码，为个人练手项目。所以，源代码开源且同时部署在GitHub和OSChina上面。 首先在OSChina上面新建项目SinaWeibo。这里没有采用SSH方式实现代码的管理，而是采用HTTPS方式来进行代码的管理。https://git.oschina.net/taofei0610/SinaWeibo.git 然后将项目Clone到的我的电脑上面，打开终端进入到代码存储的目录下，使用命令Clone下OSChina上面的项目。 12345678//用到的命令cd /Users/taofei/Documents/TFCode/TFOSChinagit clone https://git.oschina.net/taofei0610/SinaWeibo.gitcd SinaWeibotouch .gitignoregit add .git commit -m "add gitignore"git push 到此就将OSChina上面的项目Clone下来了，但是由于OSChina上面创建项目时没有swift的 .gitignore，所以我们要去GitHub中找到swift项目开发中的gitignore并将其复制后加入我们的项目中。(https://github.com/github/gitignore) 注意：一般在这里复制的.gitignore中的内容时最好将#Pods中的#去掉，这样上传时不用将CocoaPods中的文件上传， 只上传Podfile中的内容 这样关于swift的.gitignore文件就在项目中了，我们需要git对其进行管理。用命令将其加入然后提交本地最后push到OSChina即可。 下面我们就可以新建swift项目放到刚才clone下来的与.gitignore同级的目录下。用Xcode创建完项目后我们就可以利用Xcode集成的Source Controller来commit，push项目代码了，当然命令行重度用户可以继续命令行也是特别好的。（此过程中第一次要输入OSChina的账号密码，直接输入就好了。）到此，项目部署完毕。 注意：这里项目名称一定要规范尽量不要出现特殊的符号 项目的基本设置项目配置 部署版本（Deployment Target）：本项目支持9.0及以上版本。（Swift很多要用到的语法比较新） 设备（Devices）：iPhone 设备方向（Device Orientation）：本项目只支持竖屏。 启动图片（Launch Screen Source）:Use Asset Catalog. 到这里我们可以将已有的启动图片添加到项目的启动图片文件夹中了。要想尽量没有警告可以将没有用到的items移除。项目图标也是同样。 这里APP在模拟器上显示的是用们的项目名称，要想让其显示对用户比较有好多名称在项目的info.plist文件中修该Bundle name（或者Bundle display name） 后面的值为自己想要显示给用户的名称即可。我这里改为：微博。 最后设置下项目前缀（class prefix）：TF 整理项目文件目录结构加入classes文件夹，里面分为：Main,Home,Message,Discover,Profile. 注意：整理完目录结构要记得提交,另外这里整理项目目录时最好创建真实的文件夹,二不是在Xcode中新建Group,这样便于以后管理 纯代码方式创建项目基本步骤： 将MainInterface -&gt; nil 创建Window -&gt; 设置根控制器 创建TFMainTabBarController 添加子控制器 创建子控制器 设置属性title，tabBar.image/selectImage 包装导航控制器 添加子控制器 一般现在公司用storyboard还是比较多的，苹果推出的很多技术都是storyboard相关的。本项目用纯代码来实现是为了在此过程中熟练swift开发。 既然是纯代码方式就要将Main Interface中的main去掉，然后自己在AppDelegate中创建Window。 1234//创建Window,设置根控制器，显示windowwindow = UIWindow(frame: UIScreen.main.bounds)window?.rootViewController=TFMainTabBarController()window?.makeKeyAndVisible() 创建窗口的跟控制器为：TFMainTabBarController，放在Main文件夹中。在AppDelegate中设置window的跟控制器时使用到TFMainTabBarController时不需要import。 首先要解决默认蓝色的tabBarItem选项的问题 12//解决解决默认蓝色的tabBarItem选项图片的问题,要在TFMainTabBarController中设置tintColortabBar.tintColor = UIColor.orange 123//或者在AppDelegate中设置tabBar的全局背景色//设置tabBar全局颜色UITabBar.appearance().tintColor = UIColor.orange 在TFMainTabBarController中我们要添加最少五个控制器，其中四个是类似的。所以，在此我们可以重载addChildViewController方法（OC中不允许这样写,这种写法类似Java中的方法的重载,函数名称可以相同，参数类型不同或者个数不同），并将其设置为private。将具体的添加子控制器要做的事封装在这个方法中。然后在主控制器中添加这四个相似的子控制器。 12345678910111213141516171819202122232425262728293031//MARK:- 初始化UIextension TFMainTabBarController&#123; /// 初始化UI界面 func setupUI()&#123; //添加tabBarController的子控制器 addChildViewController(childVc: TFHomeViewController(), title: "首页", imageName: "tabbar_home") addChildViewController(childVc: TFMessageViewController(), title: "消息", imageName: "tabbar_message_center") addChildViewController(childVc: TFDiscoverViewController(), title: "发现", imageName: "tabbar_discover") addChildViewController(childVc: TFProfileViewController(), title: "我", imageName: "tabbar_message_center") &#125; //该类的私有方法private，在当前文件中可以访问，但是在其他文件中不能访问 //swift支持方法的重载，方法名称相同，但是参数不同 --&gt;1.参数的类型不同，2.参数的个数不同 //private修饰后在当前文件中可以访问，但是其他文件不可以访问 private func addChildViewController(childVc : UIViewController,title : String,imageName :String) &#123; //1.设置子控制器的属性 childVc.title=title childVc.tabBarItem.image = UIImage(named: imageName) childVc.tabBarItem.selectedImage = UIImage(named: imageName + "_highlighted") //2.包装导航控制器 let childNacVc = UINavigationController(rootViewController: childVc) //3.添加到父控制器中 addChildViewController(childNacVc) &#125;&#125; 通过字符串创建对象当然也可以传字符串给函数，让去创建子控制器 注意:Swift中的类的全称是带有命名空间的，例如：SinaWeiBo.TFMainTabBarController 获取命名空间nameSpace 根据字符串获取对应的Class 将对应的AnyObject转换成控制器的类型 123456789101112131415161718192021//0.1获取命名空间，根据字符串创建控制器//获取infoplist文件内容，这里可以强制解包let nameSpace = Bundle.main.infoDictionary!//CFBundleExecutable是命名空间在infoplist中的编码guard let childController = NSClassFromString(nameSpace + "." + guard let nameSpace = Bundle.main.infoDictionary!["CFBundleExecutable"] as? String else&#123; TFLog("没有获取到命名空间") return &#125;guard let _ = NSClassFromString(nameSpace + "." + "TFHomeViewController")else&#123; TFLog("根据字符串创建控制器失败") return&#125;//0.2将对应的AnyClass转换为控制器类型guard let childVCType = childController as? UIViewController.Type else&#123; TFLog("没有获取到对应控制器的类型") return&#125; //0.3根据控制器类型创建控制器let vc = childVCType.init() 注意：想要拿到类的名称创建控制器要加上命名空间 通过JSON文件去创建控制器上面通过字符串创建控制器看上去很是蛋疼，但是其实还是有用的。我们可以利用这点要根据json(JavaScript Object Notation)文件去创建控制器。 通过上面利用json文件来决定创建几个控制器或者什么样的控制（前提是之前APP中已经有这样的控制器文件），这样就可以实现由服务器来决定APP上显示什么样的控制器。使得APP上显示更加灵活，同时可以通过随时改变json文件来实现软件的改变。 获取json文件路径：jsonPath 读取json文件中的内容：按二进制数据方式读取 将Data转成数组 遍历字典获取对应的信息 获取控制器对应的字符串 获取控制器显示的title 获取控制器显示图标的名称imageName 创建并添加子控制器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//0.0.1获取json文件的路径guard let jsonPath = Bundle.main.path(forResource: "MainVCSettings", ofType: "json") else&#123; TFLog("没能获取到json数据") return&#125;//0.0.2读取json文件中的内容：数组-&gt;字典,要按照读取字符串的方法来读取，这里没有throwguard let jsonData = NSData(contentsOfFile: jsonPath) else&#123; TFLog("没有获取到json文件中的数据--jsonData") return&#125;//0.0.3将NSData类型转换为数组类型,数组以及数组中存放的字典,进行两层校验；guard let anyObject = try? JSONSerialization.jsonObject(with: jsonData as Data, options: .mutableContainers) else&#123; TFLog("jsonData转anyObject失败") return&#125; guard let dictArray = anyObject as? [[String :AnyObject]] else&#123; TFLog("anyObject转字典数组失败") return&#125;//遍历字典for dict in dictArray&#123;//1.获取控制器对应的字符串guard let vcName = dict["vcName"] as? String else&#123; TFLog("获取控制器对应的字符串vcName---失败") //第一个转不成要继续 continue&#125; //2.获取控制器显示的titleguard let title = dict["title"] as? String else&#123; TFLog("获取控制器显示的title---失败") continue&#125; //3.获取控制器显示图标的名称imageNameguard let imageName = dict["imageName"] as? String else&#123; TFLog("获取控制器显示图标的名称imageName---失败") continue&#125; //4.添加子控制器addChildViewController(childVc: vcName, title: title, imageName: imageName) TFLog("---------------") TFLog(dict)&#125; &#125; Storyboard方式创建项目可以将每一个模块单独分一个Storyboard，不要将很多控制器放在一个Storyboard中； iOS9后可以使用Storyboard Reference进行解决 选中要单独出来的控制器，Editor -&gt; Refactor Storyboard -&gt; save as就可以产生一个新的Storyboard中，然后进行些设置，然后绑定下控制器就可以。 本项目一开始用纯代码实现了搭建整个项目的框架，但是之前没有用过Storyboard Reference，为了练习这种方式所以后面改用了Storyboard的形式搭建整个项目的框架。 调整TabBar的Items可以在TFMainViewController的viewWillAppear中，如果在viewDidLoad中系统会自动调整回来。 其实这里设置tabBarItem中的选中图片可以直接在storyboard中实现，另外tabBarItem的enable也可以在storyboard中设置。 12345678910111213141516171819202122232425262728293031//MARK:- 懒加载属性 private lazy var imageNames = ["tabbar_home","tabbar_message_center","","tabbar_discover","tabbar_profile"] //MARK:- 系统回调函数 override func viewDidLoad() &#123; super.viewDidLoad() &#125; override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) //调整tabBar中的item setupTabBarItems() &#125; /// 调整tabBar中的item func setupTabBarItems()&#123; //1.遍历所有的item for i in 0..&lt;tabBar.items!.count&#123; //2.获取item let item = tabBar.items![i] //3.如果下标值为2，则item不可以与用户交互 if i == 2 &#123; item.isEnabled = false continue &#125; //4.设置其他item的选中时候的图片 item.selectedImage = UIImage(named: "\(imageNames[i])"+"_highlighted") &#125; &#125; 调整tabBar一般都是在viewWillAppear中调整，在viewDidLoad中调整会被系统调整回来 tabBar中添加发布按钮添加tabBar中间的加号按钮可以在viewDidLoad中添加； 创建一个按钮（懒加载） 设置属性 设置位置 12345678910111213/// 设置发布按钮 func setupComposeBtn()&#123; //1.将composeBtn添加到tabBar中 tabBar.addSubview(composeBtn) //2.设置属性 composeBtn.setBackgroundImage(UIImage(named: "tabbar_compose_button"), for: .normal) composeBtn.setBackgroundImage(UIImage(named: "tabbar_compose_button_highlighted"), for: .highlighted) composeBtn.setImage(UIImage(named: "tabbar_compose_icon_add"), for: .normal) composeBtn.setImage(UIImage(named: "tabbar_compose_icon_add_highlighted"), for: .highlighted) composeBtn.sizeToFit() //3.设置位置 composeBtn.center = CGPoint(x: tabBar.center.x, y: tabBar.bounds.size.height*0.5) &#125; Swift中的事件监听事件监听的本质是发送消息,但是发送消息是OC的特性，Swift中已经没有发送消息这个特性了 OC中是将方法包装成@SEL，然后去类中查找方法列表，根据@SEL找到imp指针（这就是函数的指针），最后执行这个方法； Swift中将一个函数声明为private，那么该函数将不会被添加到方法列表中，因此一般在extension中的函数不要用private修饰； 在private修饰前面加上@objc，那么该函数依然会被添加到函数列表中(Swift3中不是这样了) Swift中的Selector有三种写法： Selector(“方法名称”) “方法名称” Swift3中出现了新的写法：#selector(类名.方法名称) 12//例如：selector(TFMainTabBarController.composeBtnClick) 创建按钮代码的封装这里创建按钮的方法以后可能用到，在此我们可以将其进行整理封装在单独的工具类中，以实现对之前类的扩充； 创建按钮的方法可以封装成一个类方法或者一个构造方法以便以后调用； 类方法封装的实现：将方法写在extension UIButton中 12345678910111213//Swift中类方法是以Class开头的方法，类似于OC中的+开头的类方法 class func tf_creatBtn(imageName : String , bgImageName : String) -&gt; UIButton &#123; //1.创建按钮 let btn = UIButton() //2.设置按钮的属性 btn.setImage(UIImage(named : imageName), for: .normal) btn.setImage(UIImage(named : imageName + "_highlighted"), for: .highlighted) btn.setBackgroundImage(UIImage(named : bgImageName), for: .normal) btn.setBackgroundImage(UIImage(named : bgImageName + "_highlighted"), for: .highlighted) btn.sizeToFit() //返回按钮 return btn &#125; 构造方法封装的实现：Swift中还是比较推荐使用构造函数实现对象的创建的 使用convenience修饰的函数称为便利构造函数，便利构造函数一般用在对系统的类的构造方法进行扩充时使用 便利构造函数的特点： 一般写在extension里面 init前面有convenience修饰 在便利构造函数中要明确调用self.init() 12345678910//构造函数实现对象的初始化 /// 根据按钮图片和按钮的背景图片实现按钮对象的创建 convenience init(imageName : String , bgImageName : String) &#123; self.init() setImage(UIImage(named : imageName), for: .normal) setImage(UIImage(named : imageName + "_highlighted"), for: .highlighted) setBackgroundImage(UIImage(named : bgImageName), for: .normal) setBackgroundImage(UIImage(named : bgImageName + "_highlighted"), for: .highlighted) sizeToFit() &#125; 访客视图的逻辑定义一个变量isLogin来记录用户的登录状态； isLogin = false -&gt; 展示访客视图 isLogin = ture -&gt; 展示正常的信息 因为首页、消息中心、发现、我这四个模块中都存在访客视图且访客视图不一致，都要进行判断是否登录以及显示访客视图，所以应该在将这四个模块的控制器抽取一个父控制器TFBaseViewController，在这个父控制器中实现登录状态的判断以及访客视图的显示； 然后通过Xib实现访客视图的显示； 布局并设置访客视图的信息布局访客视图首页中的访客视图内容比较多，所以按照访客视图来实现比较合理； 快捷键：Command + = 可以使UIImageView与图片等大小，不至于被拉伸变形 转盘下面的背景的虚化是通过上面覆盖渐进的图片实现的；然后在Xib中进行合适的布局就可以了； 设置访客视图在TFVisitorView中抽取一个函数让其他的几个主要的控制器可以调用这个函数来设置访客视图中的内容 1234567///设置访客视图 func setupVisitorViewInfo(iconName : String ,tip :String)&#123; iconView.image = UIImage(named: iconName) tipsLabel.text = tip rotationView.isHidden = true &#125; 另外，首页中的访客视图有转盘需要加动画，也需要通过核心动画来添加动画实现 12345678910111213///添加rotationView的动画 func addRotationViewAnimation()&#123; //1.创建动画:CABasicAnimation或者CAKeyframeAnimation来实现 let rotationAnimation = CABasicAnimation(keyPath: "transform.rotation.z") //2.设置动画的属性 rotationAnimation.fromValue = 0 rotationAnimation.toValue = M_PI * 2 rotationAnimation.repeatCount = MAXFLOAT rotationAnimation.duration = 5 rotationAnimation.isRemovedOnCompletion = false //3.将动画添加到layer中 rotationView.layer.add(rotationAnimation, forKey: nil) &#125; 注意：CA存在动画所在的view下次重新出现时，动画就会停止的问题要解决 解决办法： 12//设置动画结束后将动画移除的属性为falserotationAnimation.isRemovedOnCompletion =false 导航栏上左右Item按钮的点击时间处理12345///设置导航栏左右的注册、登录按钮 func setupNavigationItem()&#123; navigationItem.leftBarButtonItem = UIBarButtonItem(title: "注册", style: .plain , target: self, action:#selector(TFBaseViewController.registerBtnClick)) navigationItem.rightBarButtonItem = UIBarButtonItem(title: "登录", style: .plain , target: self, action:#selector(TFBaseViewController.loginBtnClick)) &#125; 另外访客视图中的注册、登录按钮的点击不要在TFVisitorView中监听，因为在这里监听比较麻烦，可以在TFBaseViewController中监听比较方便 123//监听访客视图中的注册、登录按钮的点击visitorView.registerBtn.addTarget(self, action: #selector(TFBaseViewController.registerBtnClick), for: .touchUpInside)visitorView.loginBtn.addTarget(self, action: #selector(TFBaseViewController.loginBtnClick), for: .touchUpInside) 此时导航栏上的item按钮文字的颜色不是我们想要的颜色，可以在appdelegate中统一设置 12//设置navigationbar全局颜色UINavigationBar.appearance().tintColor = UIColor.orange 首页导航栏的设置设置左右两个UIBarButtonItem这里可以抽取一个UIBarButtonItem的一个便利构造函数 12345678///通过图片名称来创建UIBarButtonItem（方法二）convenience init(imageName :String) &#123; let btn = UIButton() btn.setImage(UIImage(named : imageName), for: .normal) btn.setImage(UIImage(named : imageName + "_highlighted"), for: .highlighted) btn.sizeToFit() self.init(customView : btn)&#125; 设置中间的titleView这里的titleView的图标在右边，所有要自己自定义按钮，对按钮进行布局 123456789101112131415161718192021override init(frame: CGRect) &#123; //要先调用super super.init(frame: frame) setImage(UIImage(named : "navigationbar_arrow_down"), for: .normal) setImage(UIImage(named : "navigationbar_arrow_up"), for: .selected) setTitleColor(UIColor.darkGray, for: .normal) sizeToFit()&#125;//swift中规定：重写了init(frame: frame)或者init方法，必须重写init?(coder aDecoder: NSCoder)required init?(coder aDecoder: NSCoder) &#123; fatalError("init(coder:) has not been implemented")&#125;//swift中可以直接修改对象、结构体中的成员变量的属性的override func layoutSubviews() &#123; super.layoutSubviews() titleLabel!.frame.origin.x = 0 imageView!.frame.origin.x = titleLabel!.frame.size.width + 10 &#125; 自定义弹出的控制器这里要自定义控制器并设置背景图片注意：平时present(popoverVC, animated: true, completion: nil)时，会让改控制器下面的东西都移除，要设置控制器的一个属性就不会这样了 12//自定义转场动画popoverVC.modalPresentationStyle = .custom 要设置转场动画就要设置转场代理，要遵守协议UIViewControllerTransitioningDelegate 1popoverVC.transitioningDelegate = self 改变弹出View的frame这里要自定义UIPresentationController并且重写系统的containerViewWillLayoutSubviews这个方法 12345678override func containerViewWillLayoutSubviews() &#123; super.containerViewWillLayoutSubviews() //1.设置弹出View的frame presentedView?.frame = CGRect(x: 100, y: 55, width: 180 , height: 250) //2.添加HUD setupCoverView()&#125; 设置弹出View的frame: 之前设置PopoverVC的View的frame是在TFPopPresentationController中实现的，但是这样做不合理，应该将其暴露在外面，可以在首页控制器中可以设置，可以将首页中设置的frame传递到TFPopoverAnimator，然后再传递到TFPopPresentationController； 设置的frame流程：TFHomeViewController -&gt; TFPopoverAnimator -&gt; TFPopPresentationController 设置HUD这里自定义的UIPresentationController控制器的View是加载在containerView上面的，所以在可以把HUD插入到containerView上面并且放在tableView的下面 12345678910111213///设置蒙版 func setupCoverView()&#123; //1.添加HUD containerView?.insertSubview(coverView, at: 0) //2.设置HUD属性 coverView.backgroundColor = UIColor(white: 0.5 , alpha: 0.2) coverView.frame = containerView!.bounds //3.添加手势 let tapGes = UITapGestureRecognizer(target: self, action: #selector(TFPopPresentationController.tapCoverView)) coverView.addGestureRecognizer(tapGes) &#125; 然后把点击HUD时手势函数写好 12345///点击手势func tapCoverView()&#123; presentedViewController.dismiss(animated: true, completion: nil) print("tapCoverView--点击")&#125; 转场动画的实现转场动画的实现要对实现UIViewControllerTransitioningDelegate协议，这里可以让TFHomeViewController实现相关的协议；这里设置相关的代理，并实现代理方法； 123456789101112131415161718//MARK:- 自定义转场动画代理方法的实现extension TFHomeViewController : UIViewControllerTransitioningDelegate&#123; //目的：改变frame func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -&gt; UIPresentationController? &#123; return TFPopPresentationController(presentedViewController: presented, presenting: presenting) &#125; //目的：自定义弹出动画 func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; isPresented = true return self &#125; //目的：自定义消失动画 func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; isPresented = false return self &#125;&#125; 具体的弹出、消失动画可以符合协议：UIViewControllerAnimatedTransitioning，然后实现相关的协议方法； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//MARK:- 弹出或者消失动画代理方法的实现extension TFHomeViewController : UIViewControllerAnimatedTransitioning&#123; func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; return 0.5 &#125; //获取转场的上下文:可以通过上下文获取弹出的View和消失的View //UITransitionContextViewKey.from:获取消失的View //UITransitionContextViewKey.to:获取弹出的View func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; isPresented ? animationForPresentedView(using: transitionContext) : animationForDismissedView(using: transitionContext) &#125; ///弹出动画 func animationForPresentedView(using transitionContext: UIViewControllerContextTransitioning)&#123; //1.获取弹出的View let presentedView = transitionContext.view(forKey: UITransitionContextViewKey.to)! //2.自定义转场:将弹出的View添加到ContainerView中; transitionContext.containerView.addSubview(presentedView) //3.执行动画 //设置锚点 presentedView.layer.anchorPoint = CGPoint(x: 0.5, y: 0) presentedView.transform = CGAffineTransform(scaleX: 1.0 , y: 0.0) UIView.animate(withDuration: self.transitionDuration(using: transitionContext), animations: &#123; presentedView.transform = CGAffineTransform.identity &#125;) &#123; (_) in //必须告诉上下文已经完成了动画 transitionContext.completeTransition(true) &#125; &#125; ///消失动画 func animationForDismissedView(using transitionContext: UIViewControllerContextTransitioning)&#123; //1.获取消失的View let dismissedView = transitionContext.view(forKey: UITransitionContextViewKey.from)! //2.执行动画 UIView.animate(withDuration: self.transitionDuration(using: transitionContext), animations: &#123; dismissedView.transform = CGAffineTransform(scaleX: 1.0 , y: 0.0001) &#125;) &#123; (_) in dismissedView.removeFromSuperview() //必须告诉上下文已经完成了动画 transitionContext.completeTransition(true) &#125; &#125;&#125; 自定义转场动画的封装抽取之前关于Popover相关的动画以及代理方法的实现都在TFHomeViewController中加以实现，这样可能导致首页的控制器中的代码量会越来越多，影响以后的维护，为了减少首页控制器中代码量，在此将Popover相关的动画代理方法的实现都抽取出来，新建一个类TFPopoverAnimator，对其相关的代理方法进行封装； 然后在首页中懒加载一个TFPopoverAnimator类型的对象，然后设置popoverVC的代理为这个对象； 1popoverVC.transitioningDelegate = popoverAnimator 这样就可以使首页控制器中的代码更加简洁明了； 改变titleBtn的状态之前改变标题按钮的状态实在首页控制器中进行的，而执行弹出和消失动画是在TFPopoverAnimator中实现的，这样不合理，标题按钮的状态不能根据弹出或者消失改变标题按钮的状态； 现在要实现PopoverVC弹出或者消失动画执行的同时改变标题按钮的状态，这样就要实现消息从TFPopoverAnimator到TFHomeViewController的逆向传递； 所以，这里考虑通过闭包来实现； 在TFPopoverAnimator中定义一个闭包属性 在TFPopoverAnimator的弹出或者消失动画的时候调用闭包，传递是否是弹出动画 在TFPopoverAnimator中自定义构造函数让在创建对象时就传入闭包 在TFHomeViewController中懒加载对象时就实现闭包中的动作 12345678//MARK:- 闭包var presentedCallBack : ((_ isPresented : Bool) -&gt; ())?//MARK:- 自定义构造函数//Attention:如果自定义了一个构造函数，但是没有对父类的构造函数（init）进行重写;那么自定义的构造函数会覆盖默认的构造函数init(presentedCallBack :@escaping ( _ isPresented : Bool) -&gt; ()) &#123; self.presentedCallBack = presentedCallBack&#125; 动画执行时 1presentedCallBack!(isPresented) 首页中创建Popover动画对象 1234//两个地方需要用self:1.如果在一个函数中出现了歧义；2.在闭包中使用当前对象的属性和函数lazy var popoverAnimator : TFPopoverAnimator = TFPopoverAnimator &#123; [weak self](isPresented) in self?.titleBtn.isSelected = isPresented&#125; 注意：在闭包中如果使用当前对象的属性或者调用函数也需要在前面加上self 集成cocoapods后面登录等功能要发送网络请求等，所以在此通过cocoapods来集成第三方框架； 本项目中集成的第三方框架有： AFNetworking SVProgressHUD SDWebImage SnapKit：本框架是Masonry框架团队针对Swift全新开发的一套自动布局框架 通过终端进入相应的项目文件夹，然后使用pod init命令来初始化自动生成相关的Podfile文件； 编辑Podfile文件，然后使用pod install命令进行集成第三方库； 当然，如果不希望更新本地的第三方版本，可以使用命令pod install --no-repo-update 注意： 这里最好不要用文本编辑器打开刚创建的Podfile文件，因为可能会出现引号相关问题，一般不容易debug。 最好在终端使用vim进行编辑； Swift中使用的是.framework的动态库，Swift不支持静态库以及.a 在这里遇到了一个错误 123456789MacBook-Pro:SinaWeibo taofei$ pod installAnalyzing dependenciesDownloading dependenciesInstalling AFNetworking (3.1.0)Installing SDWebImage (3.8.2)Installing SVProgressHUD (2.1.2)Installing SnapKit (3.0.2)Generating Pods projectAbort trap: 6 stackoverflow上貌似很多人是cocoapods的版本问题，而我在执行完 1sudo gem uninstall cocoapods 后不能执行 1sudo gem install cocoapods --pre 然而又报错了 12ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/xcodeproj 新报的这个错误使用下面这条命令就可以进行解决 1sudo gem install -n /usr/local/bin cocoapods --pre 用他来代替：sudo gem install cocoa pods ，这样就完美解决了。 这次遇到的Abort trap: 6错误果然是因为cocoapods的版本问题引起的，写在后重新安装即可；如果重新安装时出现上面类似的错误，使用上面的命令替换之前的安装命令一般就可以解决了；到此本项目的第三方库管理的任务就已经完成了，以后要是要添加第三方库建议在终端编辑添加。 另外，通过cocoapods集成的第三方和我们的自己写的代码不在一个包里面，所以在使用第三方时要将其导入； 封装AFNetworkAFNetwork封装成单例一般项目中使用的发送网络请求的类都是在第三方的基础上进行封装的。本项目中用到的网路请求相关的工具类时在AFNetwork基础上进行封装的； 首先，我们在AFHTTPSessionManager基础上来封装一个类：TFNetworkTools。 一般情况下我们会将我们自己封装的网络请求工具类设计成一个单例，下面我们就在Swift中设计一个单例： 123456789import AFNetworkingclass TFNetworkTools: AFHTTPSessionManager &#123; //let是线程安全的 static let shareInstance : TFNetworkTools = TFNetworkTools() //这样就可以了，Swift中写单例就是这么简单、方便&#125; iOS开发中单例的两种情况： 通过shareInstance拿到的永远都是一个单例；例如：NSUserdefault.standarUserDefaults() 不管三七二十一，永远只有一个实例； 我们设计的就是第一种。 AFNetwork封装request请求配置网络请求参数在测试封装的网络请求时，出现了错误： 12App Transport Security has blocked a cleartext HTTP (http://) resource load since it is insecure. Temporary exceptions can be configured via your app's Info.plist file.//发送网络请求失败 我们可以在Info.plist中添加App Transport Security Settings，再添加Allow Arbitrary Loads，然后将默认的NO改成YES就可以了。 改写网络请求单例如果我们需要测试用httpbin的话，那么最好对上面封装的单例进行改变； 123456789class TFNetworkTools: AFHTTPSessionManager &#123; //let是线程安全的 static let shareInstance : TFNetworkTools = &#123; let tools = TFNetworkTools() tools.responseSerializer.acceptableContentTypes?.insert("text/html") return tools &#125;()&#125; 封装请求方法网络请求一般有GET和POST两种，我们最好定义枚举类型来区分这两种类型； 12345//定义枚举类型enum TFRequestType : String&#123; case GET = "GET" case POST = "POST"&#125; 然后根据传过来的参数看来执行封装后的GET或者POST方法 123456789101112131415161718192021222324//MARK:- 封装请求方法extension TFNetworkTools&#123; func tf_getRequest(methodType : TFRequestType, URLString : String,parameters :[String : Any?])&#123; if methodType == .GET &#123; get(URLString, parameters: parameters, progress: nil, success: &#123; (task : URLSessionDataTask, result :Any?) in print("发送网络请求成功~") print(result as Any) &#125;) &#123; (task : URLSessionDataTask?, error : Error) in print("发送网络请求失败") print(error) &#125; &#125;else if methodType == .POST&#123; post(URLString, parameters: parameters, progress: nil, success: &#123; (task : URLSessionDataTask, result : Any?) in print("发送网络请求成功~") print(result as Any) &#125;) &#123; (task : URLSessionDataTask?, error : Error) in print("发送网络请求失败") print(error) &#125; &#125; &#125;&#125; 网络请求： 12//测试网络请求 TFNetworkTools.shareInstance.tf_getRequest(methodType: .POST, URLString: "http://httpbin.org/post", parameters: ["name" : "taofei" ,"age" : 18]) 封装网络请求回调之前获得的数据的打印都在工具类中进行，并没有在真正调用网络请求时使用；所以我们要在自己封装的请求方法中增加一个finished的闭包，将网络请求的结果或者错误传回来； 123456789101112131415161718192021///发送GET或者POST网络请求的封装func tf_request(methodType : TFRequestType, URLString : String,parameters :[String : Any?],finished :@escaping (_ reslut :Any? ,_ error : Error?)-&gt;())&#123; //1.定义请求成功的回调 let successCallBack = &#123; (task : URLSessionDataTask, result :Any?) in finished(result,nil) &#125; //2.定义请求失败的回调 let failureCallBack = &#123; (task : URLSessionDataTask?, error : Error) in finished(nil, error) &#125; //3.发送网络请求 if methodType == .GET &#123;//GET请求 get(URLString, parameters: parameters, progress: nil, success: successCallBack, failure: failureCallBack) &#125;else if methodType == .POST&#123;//POST请求 post(URLString, parameters: parameters, progress: nil, success: successCallBack, failure: failureCallBack) &#125;&#125; 授权登录的实现因为并非新浪微博的官方开发人员，本项目中要想实现登录要使用新浪提供的OAuth授权，大致步骤如下： 成为新浪开发者 在新浪开放平台创建一个应用程序 获取AppKey 获取AppSecret 获取回调地址 开始授权 加载新浪的网页(让用户登录) 获取code（可以用来换取AccessToken） 获取AccessToken 开始请求数据 在新浪开发者中心创建应用在新浪开发者中心登录我们自己的新浪微博账号，成为开发者后创建移动应用，获取AppKey和AppSecret； 本项目的Appkey：407405889，AppSecret：e718655baa69710c7456074d89fbda40，然后需要的回调地址需要我们自己去填写，找到应用信息，再在高级信息中填写就可以了，本项目的回调地址是本博客的地址。下面我们就要去获取让用户登录的新浪微博的登录网页，在文档-&gt;OAuth2.0授权认证，这里要获取AccessToken；点击请求用户授权Token，因为可以使用GET请求，所以我们可以在浏览器地址栏输入相应地址进行测试。 1https://api.weibo.com/oauth2/authorize?client_id=407405889&amp;redirect_uri=http://taofei.me 这样就可以来到我们的授权登录网页。 然后后进行授权，授权成功后就可以跳转到我们的回调地址，注意这时的浏览器地址栏的地址就发生了变化，在博客地址后面增加了code=dc3fecaa1a70b064eb779953ad558708，此时的code就是我们用来换取AccessToken的； 授权登录因为登录界面里面只需要加载一个网页，所以这里我们可以利用Xib快速创建一个授权登录的控制器，通过代码设置下导航栏的item和标题，然后监听下item的点击事件就可以了； 加载登录页面和执行js代码加载登录页面12345678910111213141516///加载授权登录页面func loadOAuthWebView()&#123; //1.获取登录页面的URLString let urlString = "https://api.weibo.com/oauth2/authorize?client_id=\(app_key)&amp;redirect_uri=\(redirect_uri)" TFLog(urlString) //2.创建对应的NSURL guard let url = NSURL(string: urlString)else&#123; return &#125; //3.创建NSURLRequest对象 let request = NSURLRequest(url: url as URL) //4.加载request对象 OAuthLoginWebView.loadRequest(request as URLRequest)&#125; 在整个项目中常用的或者可能用到的不变的量我们最好单独写在一个文件中，这样我们就能像之前在OC中使用宏定义一样，而且Swift中在单独一个文件中的常量的定义使用起来更加方便； 1234//MARK:- 授权登录中的常量let app_key = "407405889"let app_secret = "e718655baa69710c7456074d89fbda40"let redirect_uri = "http://taofei.me" 在Swift中执行JS代码webView在加载过程中可能在屏幕上面显示空白的信息，应该在开始进行加载webView的同时就提示用户正在加载页面。要想实现此功能应该设置webView的代理，并且实现其代理的方法。其中，设置代理可以在Xib中直接设置就可以了，代理方法的实现我们可以在控制器中增加一个extension，然后在里面实现webView的代理方法。 另外填充功能要想实现必须改变我们刚刚加载的网页里面的内容，此时我们就要利用JS来实现了。 1234567///填充 @objc func fillItemClick()&#123; //1.书写JavaScript代码 let jsCode = "document.getElementById('userId').value='745838164@qq.com';document.getElementById('passwd').value=''" //2.执行JavaScript代码 OAuthLoginWebView.stringByEvaluatingJavaScript(from: jsCode) &#125; 其中jsCode里面的字符串就是要指向的js代码 12document.getElementById('userId').value='745838164@qq.com';document.getElementById('passwd').value='' 获取授权的code我们要获取的授权code可以在回调的网页的地址栏中找到，我们要拿到回调后跳转的那个网页。其实，webView加载每一个网页都会调用shouldStartLoadxxx这个函数，我们在这里通过URLRequest获取url，然后判断下其中是否包含“code=”，如果包含说明该URL中有code，我们对这个URL进行字符串截取就可以了获得我们想要的code了。 123456789101112131415161718///当准备加载某一个页面时会执行该方法，其返回值时Bool类型；true,继续加载，false,不会继续加载func webView(_ webView: UIWebView, shouldStartLoadWith request: URLRequest, navigationType: UIWebViewNavigationType) -&gt; Bool &#123; //1.获取加载网页的URL guard let url = request.url else&#123; return true &#125; //2.获取url中的字符串 let urlString = url.absoluteString //3.判断该字符串中是否包含code guard urlString.contains("code=") else&#123; return true &#125; //4.将code截取出来 let code = urlString.components(separatedBy: "code=").last! print(urlString) print(code) return false&#125; 获取AccessToken因为本项目中绝大多数网络请求都要使用AccessToken，我们可以将获取AccessToken的函数封装到TFNetworkTools这个网络请求的工具类中，以便以后调用。 12345678910111213141516//MARK:- 请求AccessTokenextension TFNetworkTools&#123; func getAccessToken(code : String,finished :@escaping (_ result : [String : Any]?, _ error : Error?)-&gt;())&#123; //1.获取请求的URL let urlString = "https://api.weibo.com/oauth2/access_token" //2.获取请求的参数 let params = ["client_id":app_key , "client_secret":app_secret ,"grant_type":"authorization_code" , "redirect_uri":redirect_uri, "code":code] //3.发送请求 tf_request(methodType: .POST, URLString: urlString, parameters: params) &#123; (result, error) in finished(result as? [String : Any], error) &#125; &#125;&#125; 创建TFUSerAccount类 上面已经能够获取到AccessToken相关的值，我们在此创建TFUSerAccount来记录获取到的相关信息。 expires_in：access_token的生命周期，单位是秒数。 remind_in：access_token的生命周期（该参数即将废弃，开发者请使用expires_in）。 access_token：用户授权的唯一票据，用于调用微博的开放接口，同时也是第三方应用验证微博用户登录的唯一票据，第三方应用应该用该票据和自己应用内的用户建立唯一影射关系，来识别登录状态，不能使用本返回值里的UID字段来做登录识别。 uid：授权用户的UID，本字段只是为了方便开发者，减少一次user/show接口调用而返回的，第三方应用不能用此字段作为用户登录状态的识别，只有access_token才是用户授权的唯一票据。 12345678910111213//MARK:- 自定义构造函数init(dict : [String : Any]) &#123; super.init() setValuesForKeys(dict)&#125;//MARK:- 重写函数override func setValue(_ value: Any?, forUndefinedKey key: String) &#123;&#125;//MARK:- 重写descriptionoverride var description: String&#123; return dictionaryWithValues(forKeys: ["access_token","expires_in","remind_in","uid"]).description&#125; 过期日期处理之前获得的过期日期是以秒的形式显示的，不够直观，可以在TFUSerAccount中添加一个Date类型的属性随着expires_in的变化而变化。 12345var expires_in : TimeInterval = 0.0 &#123; didSet&#123; expires_date = Date(timeIntervalSinceNow: expires_in) &#125;&#125; 请求用户信息当用户获取到access_token和uid就可以用这两个参数来获取更多的用户常用信息。在获取这两个参数后，我们下面就可以进入展示用户昵称和头像的动画的那个界面了。所以，在此我们应该获取到用户相关的昵称和头像。 为了减少TFOAuthViewController中的代码以及以后方便复用，我们可以将具体发送网络请求的代码抽取放到TFNetworkTools中在TFOAuthViewController中将请求到的数据进行处理即可； 123456789101112131415161718192021222324252627///请求用户信息func loadUserInfo(account : TFUSerAccount)&#123; //1.获取access_token guard let access_token = account.access_token else &#123; return &#125; //2.获取uid guard let uid = account.uid else &#123; return &#125; //3.发送网络请求 TFNetworkTools.shareInstance.loadUserInfo(access_token: access_token, uid: uid) &#123; (result, error) in //1.错误校验 if error != nil &#123; TFLog("获取用户信息网络请求错误.") return &#125; //2.用户信息字典的校验 guard let userInfoDict = result else&#123; return &#125; //3.从字典中取出昵称和头像地址 account.screen_name = userInfoDict["screen_name"] as? String account.avatar_large = userInfoDict["avatar_large"] as? String &#125;&#125; 到此我们已经能够获取到相关的用户信息了，在后面我们还会经常用到这些信息。我们需要将这些信息保存起来。本项目中我们暂时将其归档保存起来。后面用到的是否为已经登录状态等可以专门封装一个视图模型TFUserAccountViewModel，并设计成单例。在获取到用户信息的时候要重新给TFUserAccountViewModel中的单例进行重新赋值。不然，在后面拿到的单例里面没有想要的内容。 1TFUserAccountViewModel.shareInstance.isLogin 欢迎界面欢迎页面比较简单，相对来说也是比较固定的。所以我们就在Xib中进行布局了。另外，欢迎界面的头像和昵称这些信息都在之前获取到了。 但是进入欢迎界面可能有两种情况： 没有登录成功，在OAuth授权登录成功后就直接退出登录界面跳转到欢迎界面； 之前登录过，保存过用户的登录信息且没有过期。 所以，程序启动后可能有两种初始界面，一种是游客界面，一种是直接进入欢迎界面。这样之前启动默认的MainStoryboard就要修改为在AppDelegate中进行判断然后选择进行加入的。设置默认的控制器。 1234var defaultViewController :UIViewController? &#123; let isLogin = TFUserAccountViewModel.shareInstance.isLogin return isLogin ? TFWelcomeViewController() : UIStoryboard(name: "Main", bundle: nil).instantiateInitialViewController()&#125; 欢迎界面还要设置相关的动画 1234567891011121314151617//MARK:- 系统回调函数override func viewDidLoad() &#123; super.viewDidLoad() //0.设置头像 let ProfileAvatarURLString = TFUserAccountViewModel.shareInstance.account?.avatar_large //??:如果前面的可选类型有值，将其解包，如果为nil，就使用？？后面的值 let url = URL(string: ProfileAvatarURLString ?? "") avatarView.sd_setImage(with: url, placeholderImage: UIImage(named: "avatar_default_big")) //1.改变约束的值 avatarViewBottomConstant.constant = UIScreen.main.bounds.size.height - 200 //2.执行动画 UIView.animate(withDuration: 1.5, delay: 0, usingSpringWithDamping: 0.7, initialSpringVelocity: 5.0, options: [], animations: &#123; self.view.layoutIfNeeded() &#125;) &#123; (_) in UIApplication.shared.keyWindow?.rootViewController = UIStoryboard(name: "Main", bundle: nil).instantiateInitialViewController() &#125;&#125; 首页首页json数据的请求到此我们可以完成登录，然后跳转到登录后的首页。为了获取首页中的数据，我们就要开始发请求了。相关请求地址详情请见新浪微博官方文档。 我们可以通过GET请求获取到首页的json数据，这里我常用的一个分析json数据的网站：http://www.kjson.com/ 首页json数据的请求封装在网络请求的工具类中。 1234567891011121314151617///加载首页微博信息请求func loadStatues(finished : @escaping ( _ result : [[String :Any]]?, _ error : Error?)-&gt;())&#123; //1.获取请求的URLString let urlString = "https://api.weibo.com/2/statuses/home_timeline.json" //2.获取请求参数 let params = ["access_token" : (TFUserAccountViewModel.shareInstance.account?.access_token)!]; //3.发送网络请求 tf_request(methodType: .GET, URLString: urlString, parameters: params) &#123; (result, error) in //1.获取字典的数据 guard let resultDict = result as? [String : Any] else&#123; finished(nil, error) return &#125; //2.将数组数据回调给外面的控制器 finished(resultDict["statuses"] as? [[String : Any]], error) &#125;&#125; 字典转模型在定义好模型后，要自定义模型的构造函数，使用KVC，然后重写setValue(_ value: Any?, forUndefinedKey key: String)方法。然后在首页获取到微博状态字典数组后进行遍历，将遍历到的字典转化为模型实例对象，然后加到微博的数组中，再刷新表格。 123456789101112131415161718192021func loadStatues()&#123; TFNetworkTools.shareInstance.loadStatues &#123; (result, error) in //1.错误校验 if error != nil &#123; TFLog(error) return &#125; //2.获取可选类型中的数据 guard let resultArray = result else&#123; TFLog("没有获取到首页中的微博数组") return &#125; //3.遍历微博对应的字典 for statuesDict in resultArray&#123; let status = TFStatus(dict: statuesDict) self.statusesArray.append(status) &#125; //4.刷新表格 self.tableView.reloadData() &#125;&#125; 注意：首页中的数据源代理方法numberOfSections方法必须实现，不然不能正常显示数据。 微博来源处理服务器返回的数据带有HTML标签，但是我们显示在首页的内容中不是这样的，在此我们需要对服务器返回的数据进行截串。我们在模型的微博来源属性中进行监听，然后处理相关的问题。 123456789101112var source : String?&#123; //微博来源 didSet&#123; //1.空值校验 guard let source = source, source != "" else&#123; return &#125; //2.对来源的字符串进行处理 let startIndex = (source as NSString).range(of: "&gt;").location + 1 let length = (source as NSString).range(of: "&lt;/").location - startIndex source_text = (source as NSString).substring(with: NSRange(location: startIndex, length: length)) &#125;&#125; 微博时间处理时间显示规律： 1分钟内：刚刚 1小时内：xx分钟前 1天内：xx小时前 昨天：昨天 xx:xx 一年内：xx-xx xx:xx 一年后：xxxx-xx-xx xx:xx 由于时间处理的代码较多且经常用到，在此我们就将其抽取到一个工具类中，并写成类方法，方便以后调用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556static func createDateString(_ createAtStr : String) -&gt; String &#123; // 1.创建时间格式化对象 let fmt = DateFormatter() fmt.dateFormat = "EEE MM dd HH:mm:ss Z yyyy" fmt.locale = Locale(identifier: "en") // 2.将字符串时间,转成NSDate类型 guard let createDate = fmt.date(from: createAtStr) else &#123; return "" &#125; // 3.创建当前时间 let nowDate = Date() // 4.计算创建时间和当前时间的时间差 let interval = Int(nowDate.timeIntervalSince(createDate)) // 5.对时间间隔处理 // 5.1.显示刚刚 if interval &lt; 60 &#123; return "刚刚" &#125; // 5.2.59分钟前 if interval &lt; 60 * 60 &#123; return "\(interval / 60)分钟前" &#125; // 5.3.11小时前 if interval &lt; 60 * 60 * 24 &#123; return "\(interval / (60 * 60))小时前" &#125; // 5.4.创建日历对象 let calendar = Calendar.current // 5.5.处理昨天数据: 昨天 08:38 if calendar.isDateInYesterday(createDate) &#123; fmt.dateFormat = "昨天 HH:mm" let timeStr = fmt.string(from: createDate) return timeStr &#125; // 5.6.处理一年之内: 03-22 12:22 let cmps = (calendar as NSCalendar).components(.year, from: createDate, to: nowDate, options: []) if cmps.year! &lt; 1 &#123; fmt.dateFormat = "MM-dd HH:mm" let timeStr = fmt.string(from: createDate) return timeStr &#125; // 5.7.超过一年: 2015-06-28 13:45 fmt.dateFormat = "yyyy-MM-dd HH:mm" let timeStr = fmt.string(from: createDate) return timeStr&#125; 微博发布者的用户信息 每一条微博的信息中都有微博的发布者，所以我们在封装的TFStatus中应该增加一个用户属性，增加这个用户属性需要单独封装一个TFUser的类。在创建TFStatus对象的时候要主动调用TFUser的init函数进行字典转模型。 用户数据处理请求得到的部分用户数据不能直接显示，在此要进行适当的处理，这样就要监听TFUser属性的变化。 123456789101112131415161718192021var verified_type :Int = -1&#123; didSet&#123; switch verified_type &#123; case 0: verifiedImage = UIImage(named: "avatar_vip") case 2,3,5: verifiedImage = UIImage(named: "avatar_enterprise_vip") case 220: verifiedImage = UIImage(named: "avatar_grassroot") default: verifiedImage = nil &#125; &#125;&#125; //用户认证类型var mbrank : Int = 0 &#123; didSet&#123; if mbrank &gt; 0 &amp;&amp; mbrank &lt;= 6&#123; vipImage = UIImage(named: "common_icon_membership_level\(mbrank)") &#125; &#125;&#125; 微博视图模型封装前面的微博模型和用户模型中的代码看起来比较乱。在此我们可以对之前的模型进行封装，将其封装成视图模型。将 MVC 架构调整之 MVVM。 MVVM 设计模式的一个很重要的目的就是将 Controller 瘦身； 一个控制器可以引用多个视图模型； 在工作中如果遇到量级非常重的控制器，可以针对实际的业务，将一组业务逻辑相关的代码抽取到一个独立的视图模型中处理； 这里我们可以将TFStatus中要进行处理的各种数据的处理抽取并封装到一个新的视图模型TFStatusViewModel中，在创建视图模型控制器的初始化方法中对相应的数据进行处理，并且以属性的形式保留TFStatus的对象，以便以后使用不需处理的数据。 首页中的Cell关于cell的布局，完全可以在Storyboard中进行，图像的圆形完全可以使用Storyboard中的KVC进行实现。 设置cell中的值给Storyboard中相应的cell创建一个cell并绑定进行管理。给这个cell一个TFStatusViewModel类型的属性，然后监听属性的改变，一旦属性的值发生改变我们就要重新设置cell视图中的数据。如果发现cell中设置的值不容易取得，可以将获取这些值的代码放到TFStatusViewModel中进行处理，然后cell中可以拿到后直接使用。在首页的控制器中保存TFStatusViewModel的数组，然后在tableView的数据源代理方法中设置cell对应的TFStatusViewModel类型的属性就可以实现cell视图的内容的设置。 cell底部工具条底部工具条中包含三个按钮几条分割线，直接在Storyboard中封装下放进去就可以。这里想要说的一点是不同的微博的内容不一样多，显示的高度也不一样，可以设置自动计算cell的高度。但是，除布局上的约束外还要设置tableView的两个参数。 123//设置tableViewtableView.rowHeight = UITableViewAutomaticDimensiontableView.estimatedRowHeight = 200 微博配图获取配图数据首先要获得微博配图的数据，然后对数据进行处理。所以，在TFStatus中添加属性pic_urls，然后在TFStatusViewModel中添加属性picURLs，将pic_urls进行处理后得到的数据放到picURLs中，这样我们以后就可以直接拿到配图的URL地址的数组了。 添加配图View添加配图要先删除之前内容label和底部工具条的约束，然后加入一个UICollectionView，这里随便设置个宽度和高度，具体宽高值需要在cell中根据配图的张数进行计算得到。 获取配图数据之前我们在cell中添加的picView的数据源和代理方法的实现是有一定代码量的，为了减少cell中的代码，可以单独的创建一个类TFPicCollectionView来管理cell中的配图。现在就要将UICollectionView的数据源和代理设置成自己。在storyboard中进行这样的设置是不行的，我们需要在代码中进行设置。 TFPicCollectionView的awakeFromNib方法中设置数据源代理为自己 然后在实现TFPicCollectionView中实现其数据代理方法，其中cell需要进行自定义，但是这个自定义的cell中代码量比较少，所以将这个cell的自定义放在collectionView中进行。给其加上一个图片URL的属性并对其进行监听与设置，然后将TFPicCollectionViewCell于storyboard中的cell进行绑定。 1234567891011121314//MARK:- 自定义cellclass TFPicCollectionViewCell: UICollectionViewCell &#123; //MARK:- 定义模型属性 var picURL : URL?&#123; didSet&#123; guard let picURL = picURL else &#123; return &#125; iconView.sd_setImage(with: picURL, placeholderImage: UIImage(named : "empty_picture")) &#125; &#125; //MARK:- 控件的属性 @IBOutlet weak var iconView: UIImageView!&#125; 图片的缓存在一张配图的情况下显示要实现高度一定，按宽高比进行放缩，就要先拿到要显示的图片，这里就需要做图片缓存了。 1234567891011121314151617181920212223///缓存图片func cacheImage(viewModels :[TFStatusViewModel])&#123; //0.创建group let group = DispatchGroup() //1.缓存图片 for viewModel in viewModels &#123; for picURL in viewModel.picURLs &#123; group.enter() SDWebImageManager.shared().downloadImage(with: picURL, options: [], progress: nil, completed: &#123; (_, _, _, _, _) in //到此下载了一张图片 print("下载了一张图片") group.leave() &#125;) &#125; &#125; group.notify(queue: .global()) &#123; //2.刷新表格 self.tableView.reloadData() &#125;&#125; 其实，这样做还是很奇葩的，后面会进行代码重构。 单张图片的显示单张配图时 未完待续……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift学习笔记]]></title>
      <url>%2F2016%2F03%2F16%2F2016-03-16-Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[申明:本篇博文内容属原创,如需转载请注明出处. Swift介绍 历史 2014年苹果在WWDC上发布；10年开始，一年后完成基本框架，14年6月发布； 作者：Chris Lattner； 领导过Xcode,Instruments等编译器；LLVM项目发起人与作者之一；Clang编译器的作者; 特点： 有Objective-C,JavaScript,C#,Python的影子； 提供了类似Java的命名空间(namespace)，泛型(generic),运算对象重载(operator overloading) 资源网站 The Swift Programming Language 初体验之PlaygroundPlayground是从Xcode6开始出现的；且只支持swift代码，OC代码会报错 12345678910111213141516171819202122232425// 1.swift中如何导入框架// #import &lt;UIKit/UIKit.h&gt;import UIKit// 2.如何定义标识符// int a =20 ;// swift中定义标识符：必须告诉编译器是常量还是变量// let修饰常量,定义之后不可以再修改// var修饰变量,定义之后可以修改// let/var 标识符的名称 : 标识符的数据类型 = 值let a : Int = 20 ;//a = 30;var b : Double = 1.44b = 2.44// 3.语句结束//如果一行中只有一条语句，那么该语句结束后，可以不加分号，可以省略//如果一行中有多条语句，那么需要分号分割// 4.打印内容// NSLog(@"%d",a);// 学习Python;print(a); 关于常量和变量的使用注意: 在真是使用过程中，建议先定义常量，如果需要修改再修改为变量，这样可以使程序更加安全； 常量的本质是它保存的内容地址不能修改，但是可以通过指针获取对象，拿到的内存地址对其属性进行修改； 12345678910//常量的使用注意let m :Int = 10//创建常量对象;OC创建对象：[[UIView alloc]init]//swift中创建对象: UIView()let view : UIView = UIView()//let view : UIView = UIView()view.backgroundColor = UIColor.red//Xcode8.2.1后修改的view.frame = CGRect.init(x: 0, y: 0, width: 0, height: 0)//Xcode8.2.1后修改的 view.alpha = 0.5view.isHidden = true //Bool类型与BOOL不同，Bool: true/false ，BOOL : YES/NO Swift中的数据类型 整型： 有符号 Int8:有符号8位整型…… Int:和平台相关（默认相当于OC中的NSInteger） 无符号 UInt8:无符号8位整型…… UInt:和平台相关（常用，相当于OC中的NSUInteger） 浮点型 Float:32位浮点型 Double:64位浮点型（默认） Swift中的类型推到 swift是一种强类型语言 swift中任何一个标识符都有明确的类型 注意： 如果定义一个标识符时有直接进行赋值，那么标识符后面的类型可以省略。 因为Swift中有类型推到，可以根据赋值推到出改标识符的类型 可以通过option+鼠标左键来查看变量的数据类型 123456789//数据类型,类型推到let tf = 10let taofei = 2.44let donkey = taofeilet DonkeyView = UIView()let DonkeyButton = UIButton()var feifei :Intfeifei=10 Swift中的基本计算Swift中进行基本运算时必须保证类型一致，否则会出错 相同类型之间才能进行基本运算 swift中没有隐式类型转换 12345678910//swift中的基本运算//将整型转换为浮点型:Double(标识符)let tt = 20let ff = 3.14let temptt=Double(tt)let result = temptt+ff//将浮点型转换为整型:Int(标识符)let tempff=Int(ff)let result2=tempff+tt 逻辑分支if-else-if分支的使用1234567891011121314151617181920212223//1. if 后面的（）可以省略//2. 判断句不再有非0/nil即真,判断句必须有明确的真假(Bool)let logic = 10if logic &gt; 0 &#123; print("logic大于0",logic)&#125;else&#123; print("logic小于0",logic)&#125;//swift中的else if 的用法let score = 92if score &lt; 0 || score &gt; 100 &#123; print("不合理的分数")&#125;else if score &lt; 60&#123; print("不及格")&#125;else if score &lt; 80 &#123; print("及格")&#125;else if score &lt; 90 &#123; print("良好")&#125;else if score &lt;= 100&#123; print("不错哦")&#125; 三目运算的使用1234567891011let sister = 20let brother = 22var max = 0//if-else实现if sister &gt; brother&#123; max = sister&#125;else&#123; max = brother&#125;//三目运算符实现let maxer = sister &gt; brother ? sister : brother Swift中特有的guard的使用guard是swift2.0才新增的语法；它是为了提高程序的可读性； guard语句必须带有else语句 当条件表达式为true的时候跳过else语句中的内容，执行语句组中的内容； 当条件表达式为false的时候执行else语句中的内容，跳转语句一般是return，break，continue和throw； 注意：guard必须用在函数里面 12345678910111213141516171819202122232425262728293031323334//guard的使用/* guard 条件表达式 else &#123; //执行的语句 break &#125; //语句组*/var age = 20//if-else实现func online1(age :Int) -&gt; Void &#123; if age &gt;= 18 &#123; print("可以留下来上网") &#125;else &#123; print("回家找妈妈") &#125;&#125;//guard实现func online2(age :Int) -&gt;Void&#123; guard age &gt;= 18 else&#123; print("回家找妈妈吧") return &#125; print("留下来吧")&#125;online1(age: age)//if-else实现online2(age: age)//guard实现//guard可以解决if-else复杂情况下的嵌套问题，可以避免多重嵌套 Switch的使用Swift中的Switch功能被大大的增强了； 1.switch的基本使用123456789101112// 0:男 1：女let gender = 0//1&gt; switch后面的()可以省略//2&gt; case语句结束后，break也可以省略,不会出现case穿透switch gender&#123;case 0: print("男")case 1: print("女")default: print("其他")&#125; 2. Switch的基本使用的补充 如果系统某一个case中产生case穿透，可以在case结束后跟上fallthough case后面可以判断多个条件，多个条件以逗号分割；case 0,1 3.Swift中switch的特殊用法 3.1 switch可以判断浮点型 1234567let t = 3.14switch t&#123;case 3.14 : print("是圆周率")default: print("不是圆周率")&#125; 3.2 switch可以判断字符创 12345678910111213141516let operater1 = 20let operater2 = 30let operation = "+"var resultOfOperation = 0switch operation &#123;case "+": resultOfOperation = operater1 + operater2case "-": resultOfOperation = operater1 - operater2case "*": resultOfOperation = operater1 * operater2case "/": resultOfOperation = operater1 / operater2default: print("非法操作符")&#125; 3.3 switch可以判断区间 12345678910111213141516//swift中的switch可以判断的区间//开区间：0..&lt;20 0-19//闭区间：0...20 0-20let scoreT = 88switch scoreT &#123;case 0..&lt;60: print("不及格")case 60..&lt;80: print("及格")case 80..&lt;90: print("良好")case 90...100: print("优秀")default: print("不合理的分数")&#125; 循环的使用for 循环for后面的小括号可以省略,for-in 12345678//for in循环for i in 0 ..&lt; 10 &#123; print(i)&#125;//省略变量的情况for _ in 0...9&#123; print("Hello world")&#125; 在Swift中如果一个标识符不需要使用，可以使用下划线 _ 来代替 while 和 repeat while循环12345678910//swift中的写法var randomNumeber1 = 10while randomNumeber1 &gt; 0 &#123; print(randomNumeber1) randomNumeber1 -= 1&#125;repeat &#123; randomNumeber1 += 1 print(randomNumeber1)&#125;while randomNumeber1&lt;10 字符串OC中的字符串类型是NSString类型，Swift中是String OC中字符串@””,Swift中字符串”” String和NSString之间可以无缝转换 12345//字符串let str = "Donkey-Tao is taofei"for c in str.characters &#123; print(c)&#125; 字符串的拼接 123let str1 = "Donkey-Tao"let str2 = "taofei"let str3 = str1 + str2 字符串和其他标识符之间的拼接 1234let name = "taofei"let ageOfTaofei = 18let height = 1.88let info = "my name is \(name) ,my age is \(ageOfTaofei),my height is \(height)" 拼接字符串时，字符串的格式化 1234let min = 2let second = 18let timeSting = String(format:"%02d:%02d",arguments:[min,second])//OC的数组，字典中不能放基本数据类型，swift中可以 字符串的截取 123456let urlString = "http://taofei.me"//let header = urlString.substring(to: 6)//这里比较麻烦//可以将String转化为NSStringlet header = (urlString as NSString).substring(to: 4)//let centet = (urlString as NSString).subsringWithRange(NSMakeRange(8, 13))//这个函数有点问题let footer = (urlString as NSString).substring(from: 14) 数组的使用定义数组(数组是一个泛型集合) 1&gt; 定义不可变数组:使用let修饰标识定义出来的数组就是不可变数组 12let numberArray = [10,221,90,12]let nameArray = ["taofei","Donkey-Tao"] 2&gt; 定义可变数组:使用var修饰标识符定义出来的数组就是可变数组 12//var arrayM = Array&lt;String&gt;()var arrayM = String 对可变数组的基本操作1234567arrayM.append("taofei")arrayM.append("Donkey-Tao")arrayM.append("taofei.me")arrayM.remove(at: 0)arrayMarrayM[0] = "taofei.Donkey-Tao"arrayM[1] 数组的遍历:三种遍历方式 1.根据下标 123for i in 0..&lt;arrayM.count &#123; print(arrayM[i])&#125; 2.直接遍历 123for name in arrayM &#123; print(name)&#125; 3.遍历前两个元素 1234567for i in 0..&lt;2 &#123; print(arrayM[i])&#125;for name in arrayM[0..&lt;2] &#123; print(name)&#125; 数组的合并:相同类型才可以相加合并1let resultArray = nameArray + arrayM //不同类型的数组不能相加合并 字典swift中字典也是泛型的集合 定义字典 定义不可变字典:使用let修饰 1let dict : [String : Any] = ["name" : "taofei","age" : 18]//系统会判断时数组还是字典 定义可变字典:使用var修饰 12//var dictM = Dictionary&lt;String , Any&gt;()var dictM=[String : AnyObject]() 对可变字典的基本操作123456789dictM["info"] = "Donkey-Tao" as AnyObject?dictM["name"] = "taofei" as AnyObject?dictM["age"] = 18 as AnyObject?dictMdictM.removeValue(forKey: "name")dictM//如果字典中有了对应的key进行修改,如果没有添加对应的key/valuedictM["info"] = "taofei" as AnyObject?dictM 遍历字典12345678910111213//遍历字典中所有的keyfor key in dictM.keys &#123; print(key)&#125;//遍历字典中所有的valuefor value in dictM.values &#123; print(value)&#125;//遍历字典中所有的key,valuefor (key , value) in dictM &#123; print(key) print(value)&#125; 合并字典即使类型一致也不能相加进行合并 要想实现字典合并可以将字典遍历出来一个一个加到一个可变字典中 元组 元组是Swift中特有的,OC中没有相应的数据类型 它也是一种数据结构,在数学中应用广泛 类似数组或者字典 可以用来定义一组数据 元组的定义 使用数组定义一组数据 123let array=["taofei",18,1.88] as [Any]array[0]array[1] 使用字典定义一组数据 12let dictOfInfo = ["name" : "taofei" ,"age" :18] as [String : Any]dictOfInfo["name"] 使用元组:(一般用于作为方法的返回值,可以返回多个参数) 一般写法 123let infoYuanzu = ("name" ,18 ,1.88 )infoYuanzu.0infoYuanzu.1 可以给元组的每一个元素取一个别名 12let infoYuanzu2 = (name : "taofei",18,1.85)infoYuanzu2.name 元组中元素的别名,就是元组的名称 1let (name_yuanzu,age_yuanzu,height_yuanzu) = ("taofei",18,1.85) ​ 可选类型可选类型的介绍注意:可选类型是swift中较难理解得一个知识点 在OC中,如果一个变量暂时不使用,可以赋值为0(基本数据类型)或者赋值为nil(对象类型) 在swift中,nil也是一种特殊的类型,因为和真实类型不匹配是不能赋值的(swift是强类型语言) 可选类型定义 常规方式:不常用 1var optionalName :Optional&lt;String&gt; = nil 语法糖:常用 1var optionalInfo : String? = nil 给可选类型赋值1optionalInfo = "taofei" 取出可选类型中的值可选类型 + ! :强制解包 注意:强制解包是非常危险的操作,如果可选类型为nil,强制解包系统会崩溃 建议:在强制解包前,先判断可选类型,判断是否为nil 123if optionalInfo != nil&#123;print(optionalInfo!)&#125; 可选绑定可以实现不需每次使用都要强制解包 写法一:不常用 1.判断optionalInfo是否有值,如果没有值,直接不执行{}2.如果optionalInfo有值,系统会自动将name进行解包,并且将解包后的结果赋值给tempInfo 123if let tempInfo = optionalInfo &#123;print(tempInfo)&#125; 写法二:常用 123if let optionalInfo = optionalInfo&#123;print(optionalInfo)&#125; 可选类型的应用场景1234567//1. 通过一个字符串创建NSURL对象,如果有中文是创建不出来url的let urlOptional : NSURL? = NSURL(string: "http://taofei.me")//后面返回的是NSURL的可选类型//根据url创建 if let urlOptional = urlOptional &#123;let request = NSURLRequest(url: urlOptional as URL)&#125; 函数相当于OC中的方法 1234func 函数名(参数列表) -&gt; 返回值类型 &#123;代码块return 返回值&#125; 常见函数 没有参数,没有返回值 1234func about() -&gt; Void &#123;//这里的Void可以省略print("taofei.me")&#125;about() 没有参数,有返回值 123func readMessage() -&gt; String &#123;return "学海无涯,回头是岸"&#125; 有参数,没有返回值 1234func callPhone(phoneNum : String) &#123;print("打电话给我:\(phoneNum)")&#125;callPhone(phoneNum: "18788858283") 有参数,有返回值 1234func sum(num1 : Int , num2 : Int) -&gt; Int&#123;return num1+num2&#125;print(sum(num1: 20, num2: 30)) 函数的使用注意: 内部参数与外部参数:在函数内部能够看到的参数就是内部参数,在函数外部可以看到的参数名称,默认从第二个参数开始既是内部参数也是外部参数,默认第一个参数只是内部参数,如果希望第一个也是外部参数,在标识符前面添加一个别名:在Xcode8.1.2已经不是这样了 函数设置默认参数 123456789func makeCoffee(coffeeName : String = "雀巢") -&gt; String &#123;return"制作了一杯\(coffeeName)咖啡"&#125;makeCoffee(coffeeName: "拿铁")makeCoffee(coffeeName: "卡布奇诺")makeCoffee(coffeeName: "猫屎")makeCoffee(coffeeName: "随便")makeCoffee()//默认参数 可变参数(参数的个数可变) 123456789func sumMulti(num : Int...) -&gt; Int &#123;var result = 0for n in num &#123;result += n&#125;return result&#125;sumMulti(num: 18,19,20)print(sumMulti(num: 18,19,20)) 函数参数的地址传递 1234567891011var number1 = 20var number2 = 30//默认情况下,swift函数中的参数传递也是值传递func swapNum( m :inout Int , n :inout Int)&#123;let tempNum = m;m = nn = tempNum&#125;swapNum(m: &amp;number1, n: &amp;number2)print("m=\(number1),number2=\(number2)") 函数的嵌套使用(为程序的可读性,不要用) 1234567func test()&#123;func demo()&#123;print("demo")&#125;print("test")&#125;test()//此时不会打印demo,因为只是在函数中定义了,并没有调用 ​### 类的构造函数 构造函数类似于OC中的初始化方法:init方法 默认情况下创建一个类时,必然会调用一个构造函数 即使是没有编写构造函数编译器也会提供一个默认的构造函数 如果是继承自NSObject,可以对父类的构造函数进行重写 构造函数的使用1234567891011121314151617181920212223242526272829303132333435363738394041class TFPerson : NSObject &#123;var name : String?var age : Int = 0override init() &#123;//在构造函数中,如果没有明确调用super.init(),那么系统会帮助调用print("TFPerson init")&#125;//自定义构造函数init(name :String ,age : Int)&#123;self.name = nameself.age = age&#125;//构造函数,通过一个字典初始化一个对象init(dict : [String : AnyObject])&#123;//dict["name"]是AnyObject?,要转成String?//as? 最终转成的类型是一个可选类型name = dict["name"] as? String//as! 最终转成的类型是一个确定的类型age = dict["age"] as! Intif let tempAge = dict["age"] as? Int&#123;age = tempAge&#125;&#125;//一般通过KVC实现init(dictionary : [String :AnyObject])&#123; super.init()//系统帮助自动调用是在最后调用 setValuesForKeys(dictionary) &#125; override func setValue(_ value: Any?, forUndefinedKey key: String) &#123; print("没有相应的属性") &#125;&#125;let taofei0610 = TFPerson()let taofei0512 = TFPerson(name: "TAOFEI", age: 18)print("name=\(taofei0512.name),age=\(taofei0512.age)")let taofei0513 = TFPerson(dict: ["name" : "Donkey" as AnyObject ,"age" :18 as AnyObject ,"height" : 1.85 as AnyObject]) 类的属性监听器123456789101112//属性监听器var name : String? &#123;//属性即将改变时进行监听willSet&#123; print("newValue=\(newValue)")&#125;//属性已经改变时进行监听,常用didSet&#123; print("oldValue=\(oldValue)")&#125;&#125; 监听类创建对象后对象的属性改变 闭包闭包和OC中的block非常相似 OC中的block是一个匿名的函数 Swift中的闭包是一个特殊的函数 block和闭包都是经常用于回调 注意:闭包和block一样,第一次使用时可能不习惯他的语法,可以先按照固定的格式去写,使用简单的闭包,随着学习的深入慢慢灵活应用 block的用法回顾block一般用于回调,用于网络请求(异步请求)的回调比较多 1234567891011121314151617@inerface HttpTool : NSObject//函数里面请求到的数据以block的形式回调出来,需要block参数//这里的block没有返回值,(^)表示block类型,block需要参数-(void)loadData:(void (^)(NSString *jsonData))callback;@end@implementation HttpTool-(void)loadData:(void (^)(NSString *jsonData))callback&#123; dispatch_async(dispatch_get_global_queue(0,0)^&#123; NSLog(@&quot;发送网络请求:%@&quot;,[NSThread currentThread]); dispatch_sync(dispatch_get_main_queue(),^&#123; NSLog(@&quot;拿到数据并且进行回调:%@&quot;,[NSThread currentThread]); callback(@&quot;json数据&quot;);&#125;);&#125;);&#125;@end 闭包的使用12345678910//闭包类型:(参数列表)-&gt;(返回值类型),这里的callback是函数名称func loadData(callback : (jsondata : String ) -&gt; ())&#123;dispatch_async(dispatch_get_global_queue(0,0)&#123;()-&gt; Void in print("发送网络请求\([NSThread currentThread])"); dispatch_sync(dispatch_get_main_queue(),&#123;()-&gt; Void in print("拿到数据并且进行回调\([NSThread currentThread])"); callback(jsondata : "json数据");&#125;);&#125;);&#125; 闭包循环引用的解决swift中deinit函数相当于OC中的dealloc方法,当对象被销毁时被调用 解决循环引用的方式一: 1234weak var weakself = selftool.loadData&#123;(jsondata)-&gt;() in weakself?view.backgroundColor = UIColor.red&#125; 注意:nil的内存地址就是0x0 weakself?: 如果前面的可选类型没有值,后面所有的代码都不会执行 如果前面的可选类型有值,系统会自动将weakself解包 解决循环引用的方式二:推荐 123tool.loadData&#123;[weak self] (jsondata)-&gt;() in self?view.backgroundColor = UIColor.red&#125; 解决循环引用的方式三: 12345tool.loadData&#123;[unowned self] (jsondata)-&gt;() in self.view.backgroundColor = UIColor.red&#125;//这样写比较危险,这里的self如果为空就会崩溃//unowned相当于OC中的__unsafe_unretained 注意: __weak修饰的弱引用,如果指向的对象销毁,那么指针会立马指向nil(0x0) __unsafe_unretained修饰的弱引用,如果指向的对象销毁,那么指针依然指向之前的内存地址,很容易产生”野指针”,坏内存访问 尾随闭包如果闭包作为方法的最后一个参数,那么闭包可以将()省略掉 1234//普通写法闭包tool.loadData(&#123;[weak self] (jsondata)-&gt;() in self?view.backgroundColor = UIColor.red&#125;) 12345678//尾随闭包写法一:tool.loadData&#123;[weak self] (jsondata)-&gt;() in self?view.backgroundColor = UIColor.red&#125;//尾随闭包写法二:tool.loadData()&#123;[weak self] (jsondata)-&gt;() in self?view.backgroundColor = UIColor.red&#125; Swift中的tableView简单使用1234567891011121314151617181920212223242526272829303132333435363738394041class ViewController :UIViewController&#123;// MARK:- 懒加载tableView/// tableView的属性lazy var tableView : UITableView = UITableView()&#123;// MARK:- 系统回调的函数override func viewDidLoad()&#123;super.viewDidLoad()//初始化界面setupUI()&#125;&#125;// MARK:- 设置UI界面相关extension ViewController&#123;/// 设置UI界面 func setupUI()&#123;//0.将tableView添加到控制器的View中view.addSubView(tableView)//1.设置tableView的frametableView.frame = view.bounds//2.设置数据源tableView.dataSource = self//3.设置代理tableView.delegate = self&#125;&#125;//extension类似于OC中的category,也是只能扩充方法,不能扩充属性extension ViewController :UITableViewDataSource,UITbaleViewDelegate&#123;// MARK:- 数据源和代理方法func tableView(tableView : UITableView ,numberOfRowsInSection section :Int)-&gt; Int&#123; return 20&#125;func tableView(tableView:UITabelView ,cellForRowAtIndexPath indexPath: NSIndexPath -&gt; UITableViewCell&#123;&#125;&#125; Swift中的注释: 12// MARK:- 懒加载/// tableView的属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TFLog:自定义Log]]></title>
      <url>%2F2016%2F03%2F12%2F2016-03-12-TFLog%3A%E8%87%AA%E5%AE%9A%E4%B9%89Log%2F</url>
      <content type="text"><![CDATA[申明:本篇博文内容属原创,如需转载请注明出处. 自定义Log的目的是使调试的语句在debug环境下打印,在release环境下不打印; 123456789101112131415161718192021222324//1.获取打印所在的文件let file = (#file as NSString).lastPathComponent//2.获取打印所在的方法let funcName = #function//3.获取打印所在行数let lineNumber = #function //封装成一个方法func TFLog&lt;T&gt;(message : T,file : String = #file , funcName : String = #function ,lineNum : Int = #line)&#123; let fileName = (file as NSString).lastPathComponent print("\(fileName):[\(funcName)](\(lineNum))--\(message)")&#125;TFLog(message: "TAOFEI")//方法可以不打印//封装成一个方法func TFLog&lt;T&gt;(message : T,file : String = #file , funcName : String = #function ,lineNum : Int = #line)&#123; let fileName = (file as NSString).lastPathComponent print("\(fileName):(\(lineNum))--\(message)")&#125;TFLog(message: "TAOFEI")//注意:这里的#file,#function,#function之前版本是__FILE__,__FUNCTION__,__LINE__.另外这里的T是一个动态类型 这个函数在整个项目中都要用到,这里就要封装成全局函数 任意找一个文件,在这个文件中写中,只要不写在对象函数中就可以,一般新建一个专门的文件在写类似这些功能的函数 ; Swift中没有宏定义,解决办法: 项目 -&gt;Build Setting -&gt; Swift compiler - Custom Flags (这里搜swift flag) -&gt; 在Other Swift Flags中的Debug中添加 -D DEBUG,然后在封装的代码中 1234567//封装成一个方法func TFLog&lt;T&gt;(message : T,file : String = #file , funcName : String = #function ,lineNum : Int = #line)&#123; #if DEBUG let fileName = (file as NSString).lastPathComponent print("\(fileName):(\(lineNum))--\(message)") #endif&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Swift中的异常处理]]></title>
      <url>%2F2016%2F03%2F11%2F2016-03-11-Swift%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%2F</url>
      <content type="text"><![CDATA[swift中的异常:如果在调用系统某一方法时，该方法最后有throws，说明该方法可能会抛出异常，我们需要对异常进行处理。 swift中提供了三种处理一样的方法 try方式，程序员手动处理异常。（开发中 不常用） 123456do &#123; try JSONSerialization.jsonObject(with: Data, options: .mutableContainers)&#125; catch &#123; //系统提供临时常量error print(error)&#125; 这种方式在开发中用的不多。 try? 方式 系统帮助我们处理异常，如果该方法出现了异常，则该方法返回nil；如果没有异常则放回对应的对象。要进行安全校验。常用方式 1234guard let anyObject = try? JSONSerialization.jsonObject(with: jsonData as Data, options: .mutableContainers) else&#123; TFLog("jsonData转anyObject失败") return&#125; tyr!方法 直接告诉系统，该方法没有异常。如果该方法出现了异常，那么程序会报错崩溃。（非常危险，不推荐使用） 1let anyObject = try! JSONSerialization.jsonObject(with: jsonData as Data, options: .mutableContainers) 异常的练习：正则表达式 创建正则表达式的规则 创建正则表达式对象 123456789101112131415161718//1.创建正则表达式的规则let pattern = "abc"//2.创建正则表达式对象//方式一：trydo&#123; let regex = NSRegularExpression(pattern :pattern, options : .CaseInsensitive)&#125; catch &#123; print(error)&#125;//方式二：try？do&#123; let regex = try? NSRegularExpression(pattern :pattern, options : .CaseInsensitive)&#125; catch &#123; print(error)&#125;//方式三：try!let regex = try! NSRegularExpression(pattern :pattern, options : .CaseInsensitive)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nonnull区域设置(Audited Regions)]]></title>
      <url>%2F2015%2F10%2F23%2F2015-10-23-Nonnull%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE(Audited%20Regions)%2F</url>
      <content type="text"><![CDATA[Nonnull区域设置(Audited Regions) 如果需要每个属性或每个方法都去指定nonnull和nullable，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。 12#define NS_ASSUME_NONNULL_BEGIN _Pragma(&quot;clang assume_nonnull begin&quot;)#define NS_ASSUME_NONNULL_END _Pragma(&quot;clang assume_nonnull end&quot;) 12345678NS_ASSUME_NONNULL_BEGIN@interface TestNullabilityClass () @property (nonatomic, copy) NSArray * items; - (id)itemWithName:(nullable NSString *)name; @end NS_ASSUME_NONNULL_END 在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。 不过，为了安全起见，苹果还制定了几条规则： typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。 复杂的指针类型(如id )必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id __nonnull”。 我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC项目：模仿百思不得姐项目开发总结]]></title>
      <url>%2F2015%2F03%2F12%2F2015-03-12-%E6%A8%A1%E4%BB%BF%E7%99%BE%E6%80%9D%E4%B8%8D%E5%BE%97%E5%A7%90%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[模仿百思不得姐项目 开发总结申明:本篇博文内容属原创,如需转载请注明出处. 练手项目，由于手贱将电脑版本升级为macOS Sierra导致之前的Mou不能用，清理垃圾文件时不能识别.md结尾的文件，误删了之前的博客与笔记。 本篇博文不是完整版，待完成.....囧。 项目首先做要准备好项目所需的资源.项目资源与工具:1.IPA文件:图片,图标,声音等资源找到IPA包,用Zip解压,查看包里面的内容就可以找到自己想要的文件(例如:IPA中会有 tabBar,Navigation…)2.利用Charles拦截API接口3.利用Reveal分析UI 首先基本配置,然后搭建基本的骨架项目的实现使用代码+xib实现 TFTabBarController -&gt; 4个子控制器 基本配置图片,启动图片,软件名称,目录结构项目目录结构的整理:1.资源文件放到Supporting Files里面2.把图标放到AppIcon.3.设置启动图片删除Launch Screen File中的初始设置,设置Launch images source-&gt;Migrate-&gt;Launchimages,然后将图片放入其中即可.暂时不适用,也可以删除Launchscreen.xib文件.4.改变软件的显示名称,info.plist-&gt; Bundle name -&gt;改成产品名称即:百思不得姐5.整个项目采用代码+xib的形式实现.不适用storyboard,所以可以删除main interface中的main.storyboard的配置,此时没有程序启动时没有可以加载的storyboard,要自己在appdelege中自己创建窗口,设置窗口的根控制器,然后显示窗口即可. 配置tabBar,自定义TFTabBarController UITabBarController设置为根窗口的根控制器,要向UITabBarController中添加子控制器,添加四个字控制器.设置子控制器的tabBarItem.title和tabBarItem.image. 这个项目中UITabBarController不能实现需求,所以在此我们要自定义自己的UITabBarController:TFTabBarController,将添加子控制器等操作封装到自定义的TFTabBarController里面.改变图片的rendering mode,保证图片不会被默认的渲染.设置tabBarItem的文字属性:NSForegroundColorAttributeName. 设置tabBarItem,appearance的使用(后面带有UI_APPEARANCE_SELECTOR的方法都可以通过appearance对象来统一设置).设置UITabBarItem的appearance,通过appearance统一设置所有UITabBarItem的文字属性 tabBarItem的设置要在initialize中设置. TFTabBarController中添加子控制器的方法的重构,即初始化子控制器方法的封装. 4个子控制器外层包装一个导航控制器 自定义tabBar按钮当前背景图片的尺寸currentBackgroundImage设置中间按钮的位置要自定义TFTabBar,在TFTabBar的layoutSubviews中设置位置.此时更换tabBar时遇到只读时可以使用KVC实现.在initWithFrame方法中添加中间的按钮,layoutSubviews中设置子控件的位置. 设置导航栏12345self.title=@"我的关注";//等价于self.navigationItem.title=@"我的关注";self.tabBarItem.title=@"我的关注"; 创建UIBarButtonItem的分类写个类方法快速返回一个对象,封装UIBarButtonItem的创建. 导航栏左边的返回按钮的统一设置自定义导航控制器,拦截导航控制器的push方法.自定义导航控制器:TFNavigationController,重写pushViewController方法(调用super),在此方法中设置返回按钮的样式. 在这个方法中拦截所有push进来的控制器,push进入其他控制器时隐藏tabBar.[UINavigationBar appearance]方法的调用要放在initialize方法中. 关注模块采用XIB的方式实现.设置Xib的file’s owner. 推荐关注的实现用到SVProgressHUD,AFNetworking,SDWebImageTFRecommandViewController用两个tableView实现,自定义cell的setSelected方法要自己控制,出现什么样的结果可以在此方法中实现.左边的tableView显示推荐关注的内容的分类,右边的tableView显示左边tableView选中的tableView中的具体的cell分类的内容.其中要解决的三个问题:1.点击左边的cell重复发送请求,请求右边tableView的数据,造成用户流量的浪费. 如果右边曾经没有数据发送请求,如果有数据刷新表格直接显示.一个类别对应一个数据,在类别数据模型中加入一个可变的数组,用懒加载.解决问题1,把分类的右边的用户数据加到类别模型的数据中这样问题就很容易解决.2.网络慢的情况的解决.赶紧刷新右边表格数据(如果没有数据,刷新出的表格会是空的),以免显示旧的数据给用户造成假象3.只能显示1页数据添加网络请求参数,在底部添加一个footerView,此时回出现表格公用footerView的情况,要来回切换状态.设置header,footer,以及header,footer中的方法实现网络数据的请求.下一页数据的请求要多下一页参数,这个数据要存在类别的数据模型中.这个项目的服务器返回的数据有问题, 每次刷新右边的数据时都控制右边的footer的显示或者隐藏 在block中控制刷新控件是否结束刷新状态 12/**这个类别对应的用户数据*/@property (nonatomic,strong) NSMutableArray *users; 不同的网路请求进入block中时会出现很多复杂的情况,处理办法如下: 12//处理不需要的请求,不是最后一次请求if(_params!=params) return; 特别注意退出控制器之前,要阻止请求回来,AFN发送的请求要用请求管理者(所有的请求都是他来管理)[]self.manager.operationQueue cancelAllOperations] ####分页的两种实现方法1.传页码2.传ID(最后面的ID) 磨刀不误砍材工1.该项目的类前缀:TF2.项目目录的整理:采用MVC模式3.PCH文件,项目名称,分类的导入 Prefix header -&gt; 设置路径]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[OC中内存管理的总结]]></title>
      <url>%2F2014%2F04%2F11%2F2014-04-11-OC%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[OC中内存管理的总结想必用过iPhone,Android的很多用户都会感觉iPhone在使用过程中相对比较流畅,想必一般的Android手机基本不会出现卡顿的现象,让用户有很好的用户体验.究其原因当然有很多,在此我简单总结下iOS开发中的关于内存管理的一些知识,就当开发过程中的学习笔记咯. OC中内存管理的本质iOS开发中,OC中的内存管理实际上主要指的是对OC对象的占用内存的管理.那么问题来了,为什么要管理OC对象的内存呢?这就要涉及OC程序中的内存划分,这里要考虑内存的堆内存部分与栈内存部分.栈内存部分中的内存是用系统管理的的,而堆内存部分的内存是要自己管理(干预)的,OC的对象都是存放在堆内存中.所以需要我们自己管理.OC对象是占用堆内存的.什么时候分配内存,什么时候回收内存是我们要考虑的问题.而OC对象内存的分配与回收的实际上可以等价于OC对象自动引用计数的管理.通过对OC对象的自动引用计数的加减实现对象内存的分配与回收.当一个OC对象的自动引用计数变为0,此时这个对象就会被系统回收.所以,我们要实现对OC对象的内存管理就是要实现对OC对象的自动引用计数的控制. 在MRC时代内存管理的管理范围 任何继承了NSObject的对象(OC对象存放于堆里面) 对其他非对象类型无效(int,char,float,double,struct,enum等),因为非OC对象一般放在栈里面(栈内存会被系统自动回收) 系统是如何判断什么时候需要回收一个对象所占用的内存?根据对象的引用计数器.那么什么是引用计数呢?每个OC对象都有自己的引用计数器,它是一个整数,从字面上, 可以理解为”对象被引用的次数”,也可以理解为: 它表示有多少人正在用这个对象.每个OC对象内部都有4个字节的存储空间来存放引用计数器.简单来说, 可以理解为: 引用计数器表示有多少人正在使用这个对象.当没有任何人使用这个对象时, 系统才会回收这个对象, 也就是说当对象的引用计数器为0时, 对象占用的内存就会被系统回收;如果对象的计数器不为0，那么在整个程序运行过程，它占用的内存就不可能被回收(除非整个程序已经退出).任何一个对象, 刚生下来的时候, 引用计数器都为1,当使用alloc、new或者copy创建一个对象时，对象的引用计数器默认就是1. 引用计数器的操作要想管理对象占用的内存, 就得学会操作对象的引用计数器引用计数器的常见操作: 给对象发送一条retain消息, 可以使引用计数器值+1（retain方法返回对象本身) 给对象发送一条release消息, 可以使引用计数器值-1 给对象发送retainCount消息, 可以获得当前的引用计数器值需要注意的是: release并不代表销毁\回收对象, 仅仅是计数器-1 dealloc方法那么怎样验证一个OC对象是否被销毁了呢?当一个对象的引用计数器值为0时,这个对象即将被销毁，其占用的内存被系统回收,系统会自动给对象发送一条dealloc消息.(因此, 从dealloc方法有没有被调用, 就可以判断出对象是否被销毁) dealloc方法的重写 一般会重写dealloc方法, 在这里释放相关资源, dealloc就是对象的遗言 一旦重写了dealloc方法, 就必须调用[super dealloc],并且放在最后面调用 使用注意:不能直接调用dealloc方法,一旦对象被回收了, 它占用的内存就不再可用, 坚持使用会导致程序崩溃（野指针错误） 野指针/空指针 僵尸对象:已经被销毁的对象(不能再使用的对象) 野指针:指向僵尸对象(不可用内存)的指针,给野指针发消息会报EXC_BAD_ACCESS错误. 空指针:没有指向存储空间的指针(里面存的是nil, 也就是0),给空指针发消息是没有任何反应的 为了避免野指针错误的常见办法,在对象被销毁之后, 将指向对象的指针变为空指针 关闭ARC功能Xcode4.2开始出现ARC,要回到MRC来自己管理对象的内存问题时要关闭项目ARC功能.关闭ARC步骤如下: Build Settings -&gt;Automatic Reference Counting(search)-&gt; No 开启僵尸对象监控监听僵尸对象-&gt;默认不监听-&gt; Edit schemes-&gt;diagnostics-&gt;enable zombie objects 内存管理原则苹果官方规定的内存管理原则: 谁创建谁release : 如果你通过alloc、new或[mutable]copy来创建一个对象，那么你必须调用release或autorelease 谁retain谁release :只要你调用了retain，就必须调用一次release 总结一下就是:有加就有减,曾经让对象的计数器+1，就必须在最后让对象计数器-1. set方法的内存管理12345678- (void)setHouse:(House *)house&#123; if (house != _house)&#123; // 对当前正在使用的房子（旧房子）做一次release [_house release]; // 对新房子做一次retain操作 _house = [house retain]; &#125;&#125; dealloc方法的内存管理123456- (void)dealloc&#123; // 当人不在了，代表不用房子了 // 对房子做一次release操作 [_house release]; [super dealloc];&#125; @property参数控制set方法的内存管理: retain ： release旧值，retain新值（用于OC对象） assign ： 直接赋值，不做任何内存管理(默认，用于非OC对象类型) copy ： release旧值，copy新值(一般用于NSString *) 控制需不需生成set方法: readwrite:同时生成set方法和get方法(默认) readonly:只会生成get方法 多线程管理: atomic:性能低(默认) nonatomic:性能高 控制set方法和get方法的名称: setter ： 设置set方法的名称，一定有个冒号: getter ： 设置get方法的名称 @class作用:可以简单地引用一个类.仅仅是告诉编译器有这样一个类,而不真正包含这个类中的所有的内容具体使用:在.h文件中使用@class引用一个类,在.m文件中使用#import包含这个类的.h文件 @class和#import作用上的区别:import会包含引用类的所有信息(内容),包括引用类的变量和方法,@class仅仅是告诉编译器有这么一个类,具体这个类里有什么信息,完全不知效率上的区别:如果有上百个头文件都#import了同一个文件,或者这些文件依次被#import,那么一旦最开始的头文件稍有改动,后面引用到这个文件的所有类都需要重新编译一遍,编译效率非常低.相对来讲,使用@class方式就不会出现这种问题了@class可以解决循环依赖的问题 循环retian循环retain的场景:比如A对象retain了B对象，B对象retain了A对象循环retain的弊端:这样会导致A对象和B对象永远无法释放循环retain的解决方案:当两端互相引用时，应该一端用retain、一端用assign autoreleaseautorelease方法的基本作用: 给对象发送一条autorelease消息, 会将对象放到一个自动释放池中 当自动释放池被销毁时，会对池子里面的所有对象做一次release操作 会返回对象本身 调用完autorelease方法后，对象的计数器不变 autorelease的好处: 不用再关心对象释放的时间 不用再关心什么时候调用release autorelease的使用注意: 占用内存较大的对象不要随便使用autorelease 占用内存较小的对象使用autorelease，没有太大影响 自动释放池在iOS程序运行过程中,会创建无数个池子.这些池子都是以栈结构存在（先进后出).当一个对象调用autorelease方法时,会将这个对象放到栈顶的释放池 autorelease的应用场合一般可以为类添加一个快速创建对象的类方法一般来说,除了alloc、new或copy之外的方法创建的对象都被声明了autorelease,不需要再release 在ARC时代ARC: Automatic Reference Counting(自动引用计数),Xcode4.2开始出现从iOS 5.0开始ARCARC是编译器特性,而不是运行时特性ARC不是像Java中的垃圾回收,有着本质的区别ARC的优点基本上可以避免内存泄漏,有时更快默认情况下都是强指针,ARC中没有任何强指针指向时就会被销毁ARC跟计数器关系不大,weak,弱指针指向对象被释放,弱指针会自动变成空指针而不是野指针 strong,默认情况下所有指针都是强指针,要注意循环引用的问题@property中多strong,weak两个参数 MRC项目转ARC项目Xcode –&gt; Edit –&gt; Refactor –&gt;Convert to Objective-C ARC… –&gt;Convert to Automatic Reference Counting –&gt;next以前MRC中的retain全部变为strong,release在ARC中全部消失关闭ARC Build Settings -&gt;search(Automatic Reference Counting)-&gt;No]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Block和Protocol]]></title>
      <url>%2F2014%2F01%2F01%2F2014-01-01-Block%E5%92%8CProtocol%2F</url>
      <content type="text"><![CDATA[block的基本使用什么是block?Block是iOS中比较特殊的数据类型.Block是苹果官方特别推荐使用的数据类型,应用场景比较广泛. 应用场景: 动画 多线程 集合遍历 网络请求回调 Block的作用:用来保存一段代码,可以在恰当的时间再取出来调用.功能与函数或者方法比较类似. 函数与Block的区别:函数不能在程序运行的过程中定义代码,函数是一开始的时候就已经写死的.block也是用来保存代码.Block保存代码:把代码放到大括号中,在大括号的左大括号前面加上一个^标志是一个Block(这^的目的是说明后面的代码段要交给block存储),在大括号的右边大括号后面加上分号表示这个数据类型定义结束.以上这些相当于int a=10;中的数值10;定义简单的Block变量(block跟函数很像,有返回值,有参数):没有返回值时在前面写void,把变量名括起来,前面加个^,这样就代表block类型的变量名.logDonkeyTao是这个block的变量名,logDonkeyTao的变量中就存储了大括号中的代码. void:代表是返回值类型 (^logDonkeyTao):代表block的变量名 ():代表block的参数block跟函数很像,只是在前面加一个^,然后在外面加一对括号. block的调用:logDonkeyTao(); 区别:block可以在函数里面定义也可以在外面定义,更加灵活. 12345678910 void (^logDonkeyTao)()^&#123; TFLog(@"------------"); NSLog(@"Donkey-Tao"); NSLog(@"------------");&#125; 定义一个block,存储一段代码,这段代码的功能是可以打印任意行数的* 123456789101112void (^logDonkeyTao)(int)=^(int numberOfLines)&#123; for(int i=0;i&lt;numberOfLines;i++)&#123; TFLog(@"------------"); NSLog(@"Donkey-Tao"); NSLog(@"------------"); &#125;&#125; 调用block: 定义一个block计算两个整数的和先写block: 1234567891011121314151617181920212223242526//定义有返回值有参数的blockint (^sumBlock)(int,int)=^(int num1,int num2)&#123; return num1+num2;&#125;;int c=sumBlock(10,9);int(^doubleBlock)(int);doubleBlock=^(int num)&#123; return 2*num;&#125;//调用int d=doubleBlock(18); block和typedeftypedef exisiting new;typedef int Myint; 12345678910111213141516171819202122232425//定义一个block来计算2个整数的差int (^minusBlock)(int,int)=^(int num1,int num2)&#123; return num1-num2;&#125;//定义一个block来计算2个整数的积int (^multiBlock)(int,int)=^(int num1,int num2)&#123; return num1*num2;&#125;//定义一个叫做MyBlock的数据类型,它存储的代码必须返回int,必须接受2个int类型的参数typedef int(^MyBlock)(int,int);MyBlock minusBlock=^(int num1,int num2)&#123; return num1-num2; &#125; 03-Block03-使用场景严谨:调用block之前一定要判断block是否为空 04-Block04-使用注意1.默认情况下,block里面是能够访问外面的内容的,block里面不能修改外面的数值.2.要想修改外面的值,__block int b=10;这样就可以修改外面的变量的值. 05-Protocol01-基本使用protocol翻译过来就是”协议”,协议文件中只有方法的声明.可以把多个类共有的方法抽取出来,用一个协议来表示.一个类可以遵循多份协议.一个协议也可以遵守协议. 协议与父类不同,使用协议可以少一个类,使用继承时多一个 protocol的作用: 用来声明一些方法 protocol的其他使用, 协议中的关键字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读鸟哥Linux私房菜笔记]]></title>
      <url>%2F2013%2F10%2F16%2F2013-10-16-%E8%AF%BB%E9%B8%9F%E5%93%A5Linux%E7%A7%81%E6%88%BF%E8%8F%9C%2F</url>
      <content type="text"><![CDATA[读鸟哥Linux私房菜笔记Linux的简介什么是Linux？核心(Kernel)是操作系统最底层的东西，他管理所有硬件资源的工作状态，每个操作系统都有自己的核心。 Windows是针对x86架构的硬件设计的，所以只能在x86的个人计算机上运行，Linux由于是Open Source的操作系统，所以他可以被修改成适合在各种机器上面运行的，这也就是说Linux具有可移植性； Kernel要管理的事项 系统呼叫接口(System call interface):方便developer与Kernel的交流； 进程管理(Process control):多任务时Kernel要对让CPU资源得到合理的分配； 内存管理(Memory management):Kernel实现对运行内存的管理； 文件管理(File system management):Kernel要对文件进行管理; Linux的发展历程Linux之前，Unix的历史（语言:Assembler-&gt;B-&gt;C）(Open source) Unix：BSD(Berkeley),FreeBSD,System V(AT&amp;T),AIX(IBM),DEC(HP) Minix-Unix Like：完成过程中完全没有看Unix核心源码 兼容分时系统( Compatible Time-Sharing System, CTSS )(MIT)(1960) 操作系统的发展历程： Multics(Bell,MIT,GE)(1965-1969) -&gt;File server system(Ken Thompson)(1969,Assembler)(1969) -&gt;Unics(Ken Thompson)(1969) -&gt; Unix(Dennis Ritchie)(1973) -&gt;BSD:Berkeley Software Distribution(Berkeley)(Bill Joy)(1977) -&gt;FreeBSD(X86) -&gt;1979 Version -&gt;Minix:Unix Like(Andrew Tanenbaum)(1984) -&gt;GNU Plan(Richard Mathew Stallman)(1984)(Compiler GNU C:gcc) -&gt;FSF(Free Software Foundation)(Richard Mathew Stallman) -&gt;GCC And GNU C Library -&gt;GPL(General Public License)(Copyleft)(1985) -&gt;X Window System(1984) -&gt;XFree86(X Window +Free + x86)(1988) -&gt;Linux(Linus Torvalds)(1994,Verion 1.0) Linux DistributionLinux Distribution : Red Hat,Fedora,Mandriva,Debian,Novell SuSE,Slackware,Linpus,Gentoo,Ubuntu,Centos Linux Distribution = Kernel + Kernel Tools + Free Software + Documentations +可以完整安装的程序 POSIX是一种标准规范， Linux产生以及发展过程中产生的神器编译器:Emac(Editor)-&gt;GNU C:gcc(Compiler) GNU开发的几个重要软件： Emacs GNU C (GCC) GNU C Library (glibc) Bash shell 这些软件都是跑在有专利的Unix系统上的，GNU:GNU’s Not Unix Free software目前软件:Free software,Freeware,Shareware 自由软件是Open source的，但是Open source的软件不一定就是自由软件； 如何学习LinuxLinux的应用 网络服务器：www,Mail Server,FTP Server ,etc. 工作站计算机：不提供Internet服务 桌面型计算机：上网浏览，文书处理，办公，收发电子邮件 基础学习作为CSer当然要玩一玩Command Line咯； 各硬件装置在Linux下的代号 IDE 硬盘机 /dev/hd[a-d] SCSI 硬盘机 /dev/sd[a-p] USB 随身碟 /dev/sd[a-p]与SCSI硬盘一样 CDROM /dev/cdrom 软盘机 /dev/fd[0-1] 打印机 /dev/lp[0-2] 鼠标 /dev/mouse 相关缩写： NAT: Network Address Translation SAMBA: DHCP: Dynamic Host Configuration Protocol 未完，待续~ ​​​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法：最短路径]]></title>
      <url>%2F2013%2F03%2F05%2F2013-03-05-%E7%AE%97%E6%B3%95%EF%BC%9A%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
      <content type="text"><![CDATA[声明:本文为博主原创,如需转载请注明出处. 本文中的算法用C语言进行了实现。 简介： 最短路径问题：给你n个点，m条无向边，每条边都有长度d和花费p，给你起点s终点t，要求输出起点到终点的最短距离及其花费，如果最短距离有多条路线，则输出花费最少的。 要求： 输入：输入n,m，点的编号是1~n,然后是m行，每行4个数 a,b,d,p，表示a和b之间有一条边，且其长度为d，花费为p。最后一行是两个数 s,t;起点s，终点。n和m为0时输入结束。 源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;#define MAX_VERTEX_NUM 100#define max 65536typedef struct &#123; int distance; int cost;&#125;EDG;typedef struct &#123; int n; int e; int vexs[MAX_VERTEX_NUM]; EDG edges[MAX_VERTEX_NUM][MAX_VERTEX_NUM];&#125;MGraph;void shortpat_FLOYED(MGraph *mg);MGraph *creat_MGraph();//建立邻接矩阵void main()&#123; int m,n; MGraph *mg; mg=creat_MGraph();//建立邻接矩阵 printf("请输入要求的两个顶点的序号："); scanf("%d%d",&amp;m,&amp;n); shortpat_FLOYED(mg); printf("顶点%d与顶点%d的最短路径的距离：%d花费为：%d\n",m,n,mg-&gt;edges[m][n].distance,mg-&gt;edges[m][n].cost); printf("程序结束\n");&#125;void shortpat_FLOYED(MGraph *mg)&#123; int i,j,k; for(k=1;k&lt;=mg-&gt;n;k++) for(i=1;i&lt;=mg-&gt;n;i++) for(j=1;j&lt;=mg-&gt;n;j++) &#123; if(mg-&gt;edges[i][k].distance+mg-&gt;edges[k][j].distance&lt;mg-&gt;edges[i][j].distance) &#123; mg-&gt;edges[i][j].distance=mg-&gt;edges[i][k].distance+mg-&gt;edges[k][j].distance; mg-&gt;edges[i][j].cost=mg-&gt;edges[i][k].cost+mg-&gt;edges[k][j].cost; &#125; else if(mg-&gt;edges[i][k].distance+mg-&gt;edges[k][j].distance==mg-&gt;edges[i][j].distance) &#123; if(mg-&gt;edges[i][k].cost+mg-&gt;edges[k][j].cost&lt;mg-&gt;edges[i][j].cost) mg-&gt;edges[i][j].cost=mg-&gt;edges[i][k].cost+mg-&gt;edges[k][j].cost; &#125; else ;//空语句 &#125;&#125;MGraph *creat_MGraph()//建立邻接矩阵&#123; int i,j,k,n,e,d,c; MGraph *mg=malloc(sizeof(MGraph)); printf("请输入顶点的个数："); scanf("%d",&amp;n); printf("请输入边的条数："); scanf("%d",&amp;e); mg-&gt;n=n; mg-&gt;e=e; getchar(); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) &#123; mg-&gt;edges[i][j].distance=max;//初始化邻接矩阵表示的所有边 mg-&gt;edges[i][j].cost=max; &#125; printf("请输入边的信息:\n"); for(i=1;i&lt;=e;i++) &#123; scanf("%d%d%d%d",&amp;j,&amp;k,&amp;d,&amp;c); mg-&gt;edges[j][k].distance=d; mg-&gt;edges[j][k].cost=c; mg-&gt;edges[k][j].distance=d; mg-&gt;edges[k][j].cost=c;//标记存在的边 &#125; return mg;//返回邻接矩阵的首地址&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[算法：欧拉回路]]></title>
      <url>%2F2013%2F02%2F26%2F2013-02-26-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%2F</url>
      <content type="text"><![CDATA[声明:本文为博主原创,如需转载请注明出处. 本文中的算法用C语言进行了实现。 简介： 欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。现给定一个图，问是否存在欧拉回路？ 要求：输入：测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是节点数N ( 1 &lt; N &lt; 1000 )和边数M；随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个节点的编号（节点从1到N编号）。当N为0时输入结束。 输出：每个测试用例的输出占一行，若欧拉回路存在则输出1，否则输出0。 问题分析和任务定义题目要求判断一个给定的图中是否存在欧拉回路。由欧拉图的定义，当一个图存在欧拉回路时，该图称为欧拉图。题目问是否存在欧拉回路即等价于问给定的图是否为欧拉图。所以，证明给定图是欧拉图就说明该图存在欧拉回路，否则不存在欧拉回路。根据高等教育出版社出版屈婉玲、耿素云、张立昂主编的《离散数学》P.296定理15.1可知：无向图G是欧拉图当且仅当G是连通图且没有奇度顶点。要证明一个给定的图是否为欧拉图，证明给定的图是连通图且没有奇度顶点即可。所以，解决题目中的问题就转化为证明给定图是否是连通图且没有奇度顶点。 首先要确定一给定的图是否为连通图。这里我们可以通过图的深度优先搜索遍历确定。从任意顶点出发，如果能深度优先遍历到所有的顶点就说明图中所有的顶点都是连图的即为连通图。 然后再确定给定的图是否没有奇度顶点。我们可以以邻接矩阵的形式存储给定的图，对邻接矩阵的每行分别行进行扫描，记录每个顶点的度数，当每行扫描完后判断该顶点的度数是否为奇数，存在奇度顶点直接结束扫描，说明存在奇度顶点，给定图不是欧拉图。即不存在欧拉回路。否则继续扫描，当扫描完所有的行没有发现奇度顶点，即说明给定图没有奇度顶点。 当上述两个问题都确定以后根据定理，当且仅当给定图为连通图且没有奇度顶点时给定的图为欧拉图。由此可确定，给定的图是否存在欧拉回路。 数据结构的选择与概要设计数据结构的选择图在我们所学的数据结构与算法课程中有四种存储方式：邻接矩阵、邻接表、十字链表和邻接多重表。本问题比较简单，选用邻接矩阵或邻接矩阵就足够了。在本课程设计中需要判断是否有奇度顶点和是否为连通图，用用邻接表和邻接矩阵在时间繁杂度没有什么大的差别，在空间复杂度上，因为本题是无向图，如果如果用邻接表，储存一条边要储存两次，存储指针比int型的空间消耗大，在图不是很大的情况下，邻接矩阵的空间复杂度要小。同时选用邻接矩阵很容易得到图中个顶点的度数。因为顶点只要求编号这一信息，所以就没有用结构体存储顶点信息，图用邻接矩阵要用结构体存储。结构体定义如下： 1234567typedef struct&#123; int n;//顶点个数 int e;//边的条数 int vexs[MAX_VERTEX_NUM];//一维数组储存顶点 int edges[MAX_VERTEX_NUM][MAX_VERTEX_NUM];//二维数组储存边&#125;MGraph;//图 概要设计首先将图转换为邻接矩阵存储起来，然后邻接矩阵的每一行进行搜索得图中到每个顶点的度数，如果有奇度顶点，输出：不存在欧拉回路，即可结束程序。否则继续判断给定的图是否为连通图，如果是连通图输出：存在欧拉回路；否则输出：不存在欧拉回路。结束程序。 详细设计和编码将图转化为邻接矩阵存储先输入图中顶点个个数和边的条数，对所有可能存在的边初始化为0，再依次输入边的信息，即如果顶点1,2存在相连的边，输入1 2 （1,2为自动给顶点分配的编码）。将边1,2的信息改为1。用函数 MGraph*creat_MGraph();完成，返回邻接矩阵的首地址即可。 12345678910111213141516171819202122MGraph *creat_MGraph()//建立邻接矩阵&#123; int i,j,k,n,e; MGraph *mg=malloc(sizeof(MGraph)); printf("请输入顶点的个数："); scanf("%d",&amp;n); printf("请输入边的条数："); scanf("%d",&amp;e); mg-&gt;n=n; mg-&gt;e=e; getchar(); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) mg-&gt;edges[i][j]=0;//初始化邻接矩阵表示的所有边 printf("请输入边的信息:\n"); for(i=1;i&lt;=e;i++) &#123; scanf("%d%d",&amp;j,&amp;k); mg-&gt;edges[j][k]=1;mg-&gt;edges[k][j]=1;//标记存在的边 &#125; return mg;//返回邻接矩阵的首地址&#125; 搜索有没有奇度顶点对邻接矩阵的每一行进行搜索，用num记录顶点的度数（每次对新的顶点记录前都将num置为0）。为了排除顶点自身环对判断的影响，当遇到边的两顶点相同，忽略不计，这样不会对结果产生影响。如果搜索到奇度顶点则结束int Euleriancycle(MGraph *mg);函数，返回0，搜索完成且没有发现奇度顶点则返回1. 12345678910111213141516int Euleriancycle(MGraph *mg)//判断是否存在欧拉回路&#123; int i,j,num; for(i=1;i&lt;=mg-&gt;n;i++)//从第一个顶点开始，判断顶点的度数 &#123; num=0;//初始化每个顶点的度数为0 for(j=1;j&lt;=mg-&gt;n;j++) &#123; if((mg-&gt;edges[i][j]!=0)&amp;&amp;(i!=j))//如果顶点i到j的边存在度数加1 num=num+1; &#125; if(num%2==1)//如果有哪个顶点的度数为奇数，直接退出循环，返回0 return 0; &#125; return 1;//当所有的顶点都判断完成还没有退出本函数说明所有顶点度数均为偶数，返回1&#125; 判断给定的图是否为连通图本程序的深度优先遍历是一个递归的过程。其中visited[MAX_VERTEX_NUM]是一个辅助的全局变量，初始值均为0.表示该顶点没有被访问。访问后用1表示。在深度优先搜索时。我们需要调用dfs_trave()函数。在dfs_trave()中，针对每个没有被访问过的顶点调用dfs()函数，它是一个递归函数，完成从该顶点开始的深度优先搜索。如果图是一个连通图，那么完成对visited数组的初始化后，在dfs_trave()中只需调用dfs()函数一次即可完成对图的遍历。当图不是一个连通图时，则在dfs_trave()中需要针对每个连通分量分别调用dfs()函数。根据dfs()函数被调用的次数就可以判断给定的图是否为连通图。如果dfs()函数被调用一次则给定的图是连通图，否则不是连通图。 12345678910111213141516171819202122int dfs_trave(MGraph *mg)//深度优先搜索遍历&#123; int i,m=0; for(i=1;i&lt;=mg-&gt;n;i++)//将辅助变量全部初始化为0，表明顶点没有被访问过 visited[i]=0; for(i=1;i&lt;=mg-&gt;n;i++) if(visited[i]==0)//对没有访问过的顶点，调用深度优先搜索函数 &#123; dfs(mg,i);//深度优先搜索 m=m+1;//如果是非连通图，要调用1次以上，m用来记录调用dfs函数的次数 &#125; return m;//返回调用dfs函数的次数&#125;void dfs(MGraph *mg,int i)//深度优先搜索&#123; int j; visited[i]=1;//访问该顶点 for(j=1;j&lt;=mg-&gt;n;j++) if((visited[j]==0)&amp;&amp;(mg-&gt;edges[i][j]==1))//当顶点没有被访问过并且两顶点存在边 dfs(mg,j);//对该顶点深度优先搜索&#125; 根据上述2,3可知必须为连通图且没有奇度顶点才是欧拉图即存在欧拉回路 流程图 调试过程中遇到的问题本次实验中也遇到了一些小问题，通过在适当的位置加一些printf语句即可确定出现问题的语句大概的位置。加以分析、修改即可。 在本次课程设计的第三组数据的测试时出现了不存在欧拉图的错误结果，仔细分析可知，在（2,2）邻接矩阵的对角线上，所以该点的度数在计算的时候就少1度。所以，在if((mg-&gt;edges[i][j]!=0)&amp;&amp;(i!=j))//如果顶点i到j的边存在度数加1 的判断中增加了一个判断，当该点存在环，则在度数的计数时忽略不计，这样不会印象该点度数奇偶性的变化。这样就很好的解决了，存在环对判断结果的印象的问题。 通过本次课程设计让我更加深刻的体会到调试程序需要平心静气，仔细分析、研究。要有一个严谨的态度，这样才能高效率的写出优质的代码。 测试结果与分析测试数据的选择在测试中考虑到多种情况使用了多组数据，分别根据是否为连通图、是否没有奇度顶点设计了一下四组数据。第一组数据为连通图且没有奇度顶点，第二组数据为连通图且有奇度顶点，第三组数据为连通图、没有奇度顶点且有环，第四组数据为非连通图且有奇度顶点，第五组数据为非连通图且没有奇度顶点。 每组数据进行多次测试。 测试1测试数据1： 3 3 1 2 1 3 2 3 测试结果： 结果分析：测试数据表示一个3个顶点，3条边的图，顶点两两相连，存在欧拉回路。测试结果正确。 测试2测试数据2： 3 3 3 2 1 2 2 3 测试结果： 结果分析：测试数据表示一个3个顶点，3条边的图，1,、2相连，2、3相连，不存在欧拉回路。测试结果正确。 测试3测试数据:3： 4 5 1 2 1 3 2 4 3 4 2 2 测试结果： 结果分析：测试数据表示一个4个顶点，5条边的图，1、2相连，1、3相连,2、4相连,3、4相连，2、2相连。存在欧拉回路。测试结果正确。 测试4测试数据4： 5 4 1 2 3 4 4 5 3 5 测试结果： 结果分析：测试数据表示一个5个顶点，4条边的图，1、2相连，3、4相连,4、5相连,3、5相连。不存在欧拉回路。测试结果正确。 测试5测试数据5： 6 6 1 2 1 3 2 3 4 5 4 6 5 6 测试结果： 结果分析：测试数据表示一个6个顶点，6条边的图，1、2相连，1、3相连,2、3相连,4、5相连，4、6相连，5、6相连。不存在欧拉回路。测试结果正确。 测试结果总结通过对多种情况设计了多组数据多次测试如上，结果都得到了真确的结论。说明程序符合题目的要求，达到了实验的目的。 用户使用说明首先本程序中的所有顶点编号为1-N的整数。(0&lt;N&lt;1000) 先输入图顶点的个数要求为一个正整数n，然后输入图所有边的条数要求为正整数e，再图边数行整形数，每行两个数（用空格相隔）表示一条边所连接的两个顶点编号。输出结果即为题目的解。 附录源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;malloc.h&gt;#define MAX_VERTEX_NUM 1000//顶点的最大个数typedef struct&#123; int n;//顶点个数 int e;//边的条数 int vexs[MAX_VERTEX_NUM];//一维数组储存顶点 int edges[MAX_VERTEX_NUM][MAX_VERTEX_NUM];//二维数组储存边&#125;MGraph;//图int visited[MAX_VERTEX_NUM];//全局变量。在对顶点进行深度优先搜索遍历时的辅助变量数组int Euleriancycle(MGraph *mg);//判断顶点的度数是否全为偶数，有奇数时输出0，全为偶数时输出1MGraph *creat_MGraph();//将图转化为邻接矩阵储存起来，返回邻接矩阵的首地址int dfs_trave(MGraph *mg);//深度优先搜索遍历void dfs(MGraph *mg,int i);//深度优先搜索void main()&#123; int num,m;//num用来接收顶点度数判断的结果，m用来接收图是否为连通图的结果 MGraph *mg; mg=creat_MGraph();//建立邻接矩阵 num=Euleriancycle(mg);//判断顶点的度数是否全为偶数。全为偶数时num=1；否则num=0 if(num!=1) &#123; printf("不存在欧拉图！\n"); getchar(); exit(0); &#125; m=dfs_trave(mg);//判断图是否为连通图 if(m!=1) printf("不存在欧拉图！\n"); else printf("存在欧拉图！\n"); getch();&#125;MGraph *creat_MGraph()//建立邻接矩阵&#123; int i,j,k,n,e; MGraph *mg=malloc(sizeof(MGraph)); printf("请输入顶点的个数："); scanf("%d",&amp;n); printf("请输入边的条数："); scanf("%d",&amp;e); mg-&gt;n=n; mg-&gt;e=e; getchar(); for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) mg-&gt;edges[i][j]=0;//初始化邻接矩阵表示的所有边 printf("请输入边的信息:\n"); for(i=1;i&lt;=e;i++) &#123; scanf("%d%d",&amp;j,&amp;k); mg-&gt;edges[j][k]=1;mg-&gt;edges[k][j]=1;//标记存在的边 &#125; return mg;//返回邻接矩阵的首地址&#125;int Euleriancycle(MGraph *mg)//判断是否存在欧拉回路&#123; int i,j,num; for(i=1;i&lt;=mg-&gt;n;i++)//从第一个顶点开始，判断顶点的度数 &#123; num=0;//初始化每个顶点的度数为0 for(j=1;j&lt;=mg-&gt;n;j++) &#123; If((mg-&gt;edges[i][j]!=0)&amp;&amp;(i!=j))//如果顶点i到j的边存在度数加1 num=num+1; &#125; if(num%2==1)//如果有哪个顶点的度数为奇数，直接退出循环，返回0 return 0; &#125; return 1;//当所有的顶点都判断完成还没有退出本函数说明所有顶点度数均为偶数，返回1&#125;int dfs_trave(MGraph *mg)//深度优先搜索遍历&#123; int i,m=0; for(i=1;i&lt;=mg-&gt;n;i++)//将辅助变量全部初始化为0，表明顶点没有被访问过 visited[i]=0; for(i=1;i&lt;=mg-&gt;n;i++) if(visited[i]==0)//对没有访问过的顶点，调用深度优先搜索函数 &#123; dfs(mg,i);//深度优先搜索 m=m+1;//如果是非连通图，要调用1次以上，m用来记录调用dfs函数的次数 &#125; return m;//返回调用dfs函数的次数&#125;void dfs(MGraph *mg,int i)//深度优先搜索&#123; int j; visited[i]=1;//访问该顶点 for(j=1;j&lt;=mg-&gt;n;j++) if((visited[j]==0)&amp;&amp;(mg-&gt;edges[i][j]==1))//当顶点没有被访问过并且两顶点存在边 dfs(mg,j);//对该顶点深度优先搜索&#125;]]></content>
    </entry>

    
  
  
</search>
